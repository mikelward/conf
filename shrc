# -*- mode: sh -*-
# $Id$
#
# POSIX shell startup commands
#
# This script contains functions and settings that are common for all
# POSIX-compatible shells including bash and ksh.

### HELPER FUNCTIONS
# add a directory to the path
addpath()
{
    typeset dir
    typeset pos
    typeset var
    typeset sep
    dir=$1
    pos=$2
    var=${3:-"PATH"}
    sep=${4:-":"}
    OIFS="$IFS"
    IFS="$sep"

    case "$pos" in
    start)
        delpath "$dir" "$var" "$sep"
        eval $var="\$dir""\${$var:+\$sep}""\$$var"
        ;;
    end)
        delpath "$dir" "$var" "$sep"
        eval $var="\$$var""\${$var:+\$sep}""\$dir"
        ;;
    *)
        typeset dirs
        typeset seen
        eval dirs=\$$var
        for d in $dirs
        do
            # directory is already in PATH, leave as is
            test "${dir:-.}" = "${d:-.}" && seen=true
        done
        test -z "$seen" && eval $var="\$$var""\${$var:+$sep}""\$dir"
        ;;
    esac
    IFS="$OIFS"
}

# remove a directory from the path
delpath()
{
    typeset dir
    typeset var
    typeset sep
    dir=$1
    var=${2:-"PATH"}
    sep=${3:-":"}
    NIFS="$IFS"
    IFS="$sep"

    typeset path
    typeset dirs

    eval dirs=\$$var
    for d in $dirs
    do
        test "${d:-.}" = "${dir:-.}" && continue
        path="$path""${path:+$sep}""$d"
    done
    eval $var="\$path"
    IFS="$NIFS"
}

# return true if the command can be found, false otherwise
exists()
{
    typeset cmd
    cmd="$1"

    if type "$cmd" >/dev/null 2>&1
    then
        return 0
    else
        return 1
    fi
}

# run a simple command quietly
quiet()
{
    "$@" >/dev/null 2>&1
    return $?
}

# set the xterm title
settitle()
{
    test -z "${titlestart}" && return 0

    printf "${titlestart}$*${titlefinish}"
}

terminit()
{
    # determine the graphics mode escape sequences
    if exists tput
    then
        bold="`tput bold`"
        underline="`tput smul`"
        normal="`tput sgr0`"
        black="`tput setaf 0`"
        red="`tput setaf 1`"
        green="`tput setaf 2`"
        yellow="`tput setaf 3`"
        blue="`tput setaf 4`"
        magenta="`tput setaf 5`"
        cyan="`tput setaf 6`"
        white="`tput setaf 7`"
    fi

    # determine the window title escape sequences
    case "$TERM" in
    aixterm|dtterm|putty|rxvt|xterm*)
        titlestart=']0;'
        titlefinish=''
        ;;
    cygwin)
        titlestart='];'
        titlefinish=''
        ;;
    screen*)
        # status line
        titlestart='_'
        # window title
        #titlestart='k'
        titlefinish='\'
        ;;
    *)
        if exists tput
        then
            titlestart=`tput tsl`
            titlefinish=`tput fsl`
        else
            titlestart=''
            titlefinish=''
        fi
        ;;
    esac
}

### SHELL ENVIRONMENT
#
typeset dir
# set directories to search for commands
# add preferred locations at start
for dir in /usr/X11R6/bin /usr/kerberos/bin /usr/posix/bin /usr/gnu/bin /usr/local/bin "$HOME"/bin
do
    test -d "$dir" && addpath "$dir" start
done
# add standard locations if they're not there
for dir in /usr/bin/X11 /usr/bin /bin
do
    test -d "$dir" && addpath "$dir"
done
# add optional locations at end
for dir in /opt/*/bin
do
    test -d "$dir" && addpath "$dir" end
done
# add the current directory to the end
for dir in .
do
    test -d "$dir" && addpath "$dir" end
done
export PATH

# set directories to search for documentation
for dir in /opt/*/info /usr/local/share/info /usr/local/info "$HOME"/info
do
    test -d "$dir" && addpath "$dir" start INFOPATH
done
for dir in /usr/share/info /usr/info
do
    test -d "$dir" && addpath "$dir" end INFOPATH
done
export INFOPATH
for dir in /usr/X11R6/man /usr/X11R5/man /opt/*/man /usr/local/share/man /usr/local/man "$HOME"/man
do
    test -d "$dir" && addpath "$dir" start MANPATH
done
for dir in /usr/share/man /usr/man
do
    test -d "$dir" && addpath "$dir" end MANPATH
done
export MANPATH

# set shell options and environment
CDPATH=":~"
HISTFILE=
HISTSIZE=128
HISTIGNORE="bg:fg: *"
HOST=`hostname`
if exists tty
then
    TTY=`tty`
else
    TTY='?'
fi
if test -z "$UID"
then
    UID=`id -u`
fi
USER=`id -un`

### ALIASES AND FUNCTIONS
# create aliases for commonly invoked commands
if quiet alias
then
    alias apt='aptitude'
    alias bell='echo "\a"'
    alias cx='chmod +x'
    alias g='egrep'
    alias h='history'
    alias l='ls'
    alias l.='l -d .*'
    alias la='l -A'
    alias ll='l -l'
    alias lt='l -t'
    alias j='jobs'
    alias nohup='nohup '
    alias pd='pushd'
    alias po='popd'
    alias psme='ps -f -U "${USER:-${LOGNAME}}"'
    alias rcslog='rlog'
    alias rdiff='rcsdiff'
    alias sudo='sudo '  # expand aliases after sudo

    # set default flags
    if quiet grep --color=auto --quiet "" "$HOME"/.shrc
    then
        alias grep='grep --color=auto'
    fi
    if quiet ls --color=auto --format=across --directory /
    then
        alias ls='ls --color=auto --format=across'
    else
        alias ls='ls -x'
    fi
fi

# show the most recently changed file
latest()
{
    if test $# -ne 0
    then
        ls -t -1 -d "$@" | head -n 1
    else
        ls -t -1 -d * | head -n 1
    fi
}

# make with an automatic log and pager
make()
{
    command make "$@" 2>&1 | tee make.log
}

# search for a pattern in text files in a directory tree
rgrep()
{
    typeset pattern
    typeset dirs
    typeset args

    args=
    while true
    do
        case $1 in
        -*)
            args="${args:+$args }$1"
            shift
            ;;
        *)
            break
            ;;
        esac
    done
    if test $# -gt 0
    then
        pattern="$1"
        shift
    else
        pattern=
    fi

    if grep -HRq "" .
    then
        grep -HR "$pattern" "${@:-.}"
    else
        find "${@:-.}" -type f -print | xargs -i grep $args "$pattern" {} /dev/null
    fi
}

# list all instances of a command
where()
{
    type -a "$@"
}

### PROGRAM SETTINGS
# set preferred generic utilities
exists lynx && export BROWSER=lynx
exists links && export BROWSER=links
exists elinks && export BROWSER=elinks
exists rsh && export CVS_RSH=rsh
exists ssh && export CVS_RSH=ssh
exists vi && export EDITOR=vi
exists vim && export EDITOR=vim
exists more && export PAGER=more
exists less && export PAGER=less
export VISUAL="$EDITOR"
export WINTERM=xterm

# set file locations
test -r "$HOME"/.inputrc && export INPUTRC="$HOME"/.inputrc

# set preferred program options
export CLICOLOR=true
export FIGNORE=
export GREP_COLOR=1
export LESS=-eFj3MRX
test -n "$TABSIZE" && export LESS="${LESS}x${TABSIZE}"
export LSCOLORS='exfxcxcxbxdxdx'
export LS_COLORS='no=00:fi=00:di=00;34:ln=00;35:or=07;35:so=00;32:pi=00;32:ex=00;31:bd=00;33:cd=00;33:'
export TOP=-I
export WANT_SSH_AGENT=1

### INTERACTIVE SETTINGS
if tty >/dev/null 2>&1
then
    # get the terminal characteristics
    terminit

    # set prompt and window title
    connectioninfo='${HOST%%.*} ${USER}'
    command=$0
    commandinfo='${command%% *}'
    shellinfo='${PWD}'
    shellinfo='${PWD##/*/}'
    if test "$UID" -eq 0
    then
        promptchars='# '
    else
        promptchars='$ '
    fi
    newline='
'

    prompt=${shellinfo}\ ${promptchars}
    title=${connectioninfo}\ ${commandinfo}

    # set command line editing key bindings
    # this must be after the EDITOR and VISUAL settings
    set -o emacs 2>/dev/null
fi

### LAST COMMANDS
# source local settings (company environment, network, etc.)
test -r "$HOME"/.shrc.local && . "$HOME"/.shrc.local

# apply the user's settings for prompt, title, etc.
PS1='`eval settitle ${title}`'"${prompt}"

