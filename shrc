#
# Configuration for bash, zsh, ksh, dash, etc.
#
# Configuration for all shells is in this one file so that it can be easily
# copied to many hosts.
#
# bashrc and zshrc should be symlinks to this file.
#
# ksh and dash should also work, but will have a simpler prompt, etc.
#
# Mikel Ward <mikel@mikelward.com>
#

###############
# COMPATIBILITY
# Try to make all shells behave similarly while reading this file

is_zsh() {
    [ -n "${ZSH_VERSION:-}" ]
}

is_bash() {
    [ -n "${BASH_VERSION:-}" ]
}

is_ksh() {
    [ -n "${KSH_VERSION:-}" ]
}

if is_zsh; then
    shell=zsh
elif is_bash; then
    shell=bash
elif is_ksh; then
    shell=ksh
else
    shell=sh
fi

case "$shell" in
zsh)
    # make zsh as similar to bash as possible
    emulate sh
    setopt BRACE_EXPAND
    setopt BANG_HIST
    setopt CSH_JUNKIE_HISTORY
    setopt INTERACTIVE_COMMENTS
    setopt KSH_TYPESET
    HISTSIZE=500
    # so we can display jobs in the prompt
    unsetopt POSIX_JOBS >/dev/null 2>&1

    # set_prompt sets PS1 to a string likely including '$', don't expand it
    unsetopt PROMPT_SUBST

    # enable ksh default features
    setopt KSH_GLOB         # !(pattern) etc. like in ksh
    unsetopt BARE_GLOB_QUAL # otherwise !(pattern) breaks

    # zsh-style autoload, required for e.g. bashcompinit
    unsetopt KSH_AUTOLOAD
    ;;
bash)
    # set_prompt sets PS1 to a string likely including '$', don't expand it
    shopt -u promptvars

    # enable ksh default features
    shopt -s extglob        # !(pattern) etc. like in ksh

    # enable zsh default features
    shopt -s globstar       # recursive globbing with **
    ;;
ksh)
    alias local=typeset
    ;;
esac

# standardize on bash-like variables that everyone assumes are preset
: ${USERNAME:=$(id -un)}
: ${HOSTNAME:=$(hostname --fqdn)}
: ${UID:=$(id -u)}
: ${TTY:=$(tty)}

#######
# PATH FUNCTIONS
# Functions used to modify $PATH
#
prepend_path() {
  local _dir=$1
  test -d "$_dir" || return
  delete_path "$_dir"
  if test -n "$PATH"; then
    PATH="$_dir:$PATH"
  else
    PATH="$_dir"
  fi
}

append_path() {
  local _dir=$1
  test -d "$_dir" || return
  delete_path "$_dir"
  if test -n "$PATH"; then
    PATH="$PATH:$_dir"
  else
    PATH="$_dir"
  fi
}

delete_path() {
  local _dir=$1
  PATH=$(
    _newpath=
    IFS=:
    for dir in $PATH; do
      if test "$dir" != "$_dir"; then
        _newpath=${_newpath:+$_newpath:}$dir
      fi
    done
    printf '%s' "$_newpath"
  )
}

inpath() {
  local _dir=$1
  (
    IFS=:
    for dir in $PATH; do
      if test "$dir" = "$_dir"; then
        return 0
      fi
    done
    return 1
  )
}

add_path() {
  local _dir=$1
  local _where=$2
  local _newpath=$PATH

  case "$_where" in start|end)
    delete_path "$_dir" "$_newpath"
    case "$_where" in
    start)
      prepend_path "$_dir" "$_newpath"
      ;;
    end)
      append_path "$_dir" "$_newpath"
      ;;
    esac
    ;;
  *)
    if ! inpath "$_dir"; then
      append_path "$_dir"
    fi
    ;;
  esac
}

#################
# BASIC FUNCTIONS
# Functions that are needed elsewhere in this file.

# print an error message
error() {
    printf "$*\n" >&2
}

# return true if the argument is a shell builtin that can be invoked
is_builtin() {
    case "$(type "$1")" in *" shell builtin")
        true
        ;;
    *)
        false
        ;;
    esac
}

# return true if the argument is a command that can be invoked
is_command() {
    test -x "$(command -v "$1")"
}

# return true if the argument is an alias, builtin, command, or function
is_runnable() {
    command -v "$1"
}

# return true if the shell is interactive
is_interactive() {
    case $- in *i*)
        true
        ;;
    *)
        false
        ;;
    esac
}

# log the running of a command to a file
log_history() {
    printf '%s\n' "$(date "+%Y%m%d %H%M%S %z") $TTY $*" >> "$HISTORY_FILE"
}

# run a command with output silenced
quiet() {
    "$@" >/dev/null 2>&1
}

# run a command, or just print what would be run if SIMULATE is true
run() {
    if ${SIMULATE:-false}; then
        echo "Would run $*"
    else
        logger -p user.info "Running $*"
        "$@"
    fi
}

# print an important message that's not quite an error
warn() {
    printf "$*\n" >&2
}

###################
# GENERAL FUNCTIONS
# Useful things that could be commands if distributing them wasn't impractical.

# look up a hostname in DNS, output both A and AAAA records
addr() {
    dig +noall +answer +search "$1" a "$1" aaaa | get_address_records
}

ptr() {
    dig +noall +answer -x "$1" ptr | get_ptr_records
}

# read BIND-style DNS entries, print the A and AAAA records
get_address_records() {
    awk '$3 == "IN" && $4 ~ /^A/ { print $5 }'
}

# read BIND-style DNS entries, print the PTR records
get_ptr_records() {
    awk '$3 == "IN" && $4 == "PTR" { print $5 }'
}

# list this machine's IP addresses
ips() {
    ip -o a sh up primary scope global | while read num iface afam addr rest; do
      case "$afam" in inet*)
          echo $iface $addr;;
      esac
    done
}
alias addrs=ips

# list this machine's MAC addresses
# format: <iface> <MAC addr>[\n<iface> <MAC addr>]*
macs() {
    ip -s l sh | sed -n '
/^[0-9][0-9]*:/{
s/^[0-9][0-9]*: \([^:]*\).*/\1/
h
}
/^    link\/ether/{
s/^    link\/ether \([^ ]*\).*/ \1/
H
x
s/\n//
p
}
'
}

# ring the terminal's bell
bell() {
    printf "\a"
}

# print the first line of input (the header) as-is, run a command
# on the rest the input (the body)
# e.g. ps | body grep ps
#
# accepts an option -<number>, makes the header <number> lines
# instead of 1
# e.g. netstat -tn | body -2 grep ':22\>'
body() {
    local lines

    lines=1
    case "$1" in -*)
        lines=${1#-}
        shift
        ;;
    esac

    while test $lines -gt 0; do
        IFS= read -r header
        printf '%s\n' "$header"
        lines=$((lines-1))
    done
    "$@"
}

# cd to the real directory that the specified file is in, resolving symlinks
cdfile() {
    cd "$(realdir "$1")"
}

delline() {
    sed -i -e ${1}d "$2"
}

# print the block device associated with the given mount point (or file)
dev() {
    df -Pk "$1" | while read fs blocks used avail cap mount; do
        case "$mount" in /*)
            echo "$fs"
        esac
    done
}

# run a command on each line of stdin
each() {
  local _line
  while IFS=$'\n' read -r _line; do
    "$@" "$_line"
  done
}

# run a command on each null-delimited parameter from stdin
each0() {
  local _arg
  while IFS= read -d '' -r _arg; do
    "$@" "$_arg"
  done
}

# print the name of a source file's corresponding test file
find_test_file() {
    local file
    local dir
    local base
    local ext
    local testfile

    file=${1##*/}
    dir=${1%$file}
    base=${file%.*}
    ext=${file#$base}

    testfile=${dir:+$dir/}${base}_test$ext
    [ -e "$testfile" ] && printf '%s' "$testfile"
}

# replace a file with a sorted version of itself
isort() {
    sort "$1" >"$1".bak
    mv "$1".bak "$1"
}

# join the arguments list by inserting a character between each element
# the first argument is the separator, the rest are the words to join
join() {
  (
    IFS=$1
    shift
    echo "$*"
  )
}

# make a directory and cd to it
mcd()
{
    if test -d "$1"; then
        printf "%s already exists\n" "$1"
    else
        mkdir -p "$1" && cd "$1"
    fi
}

# make a temporary directory and cd to it
mtd()
{
    cd "$(mktemp -d)"
}

# get this machine's public IP address as seen by Google
myip()
{
    dig +short o-o.myaddr.l.google.com txt @ns1.google.com | tr -d '"'
}

# print the list of nameservers
names() {
    grep '^nameserver' /etc/resolv.conf
    nmcli dev list 2>/dev/null | sed -ne '/domain_name_servers/{s/[^ ]*: *//;p}'
}

# print the full path to an executable, ignoring aliases and functions
# like whence -p/type -P, but should work in all shells
path()
{
    (
        IFS=:
        for d in $PATH; do
            if test -x "$d/$1"; then
                echo "$d/$1"
                return
            fi
        done
        false
    )
}

# list processes in the specified process group
# pgroup <pgid> [<pgrep args>]
pgroup() {
    pgrep -g "$@"
}

# grep for a pattern in the environments of processes matching the given pattern
# pegrep <environment pattern> <process pattern>
# e.g. pegrep SSH_AUTH_SOCK xfce4
pegrep() {
    for pid in $(pgrep -f "^$2"); do
        printf '%s %s\n' "$(ps -o pid= -o args= -p $pid)" "$(envgrep "$1" $pid)"
    done
}
alias peg=pegrep

# grep for a pattern in the environment of processes with the given pids
# envgrep <environment pattern> <pid>...
envgrep() {
    local pattern
    local pid
    pattern="$1"
    shift
    for pid in "$@"; do
        grep -z "$pattern" /proc/$pid/environ
    done
}

# ps with useful default options
psc()
{
    # user,pid,ppid,pgid,start_time,pcpu,rss,comm are first, followed by any -o option
    # the user supplies, then args are last.
    ps -w -o user,pid,ppid,pgid,start_time,pcpu,rss,comm=EXE "$@" -o args=ARGS
}

# pgrep with default ps options
# psgrep [<ps options>] <pattern>
psgrep()
{
    # last arg is pgrep pattern, rest are args for ps
    local ps_args
    while test $# -gt 1; do
        ps_args="$ps_args $1"
        shift
    done

    local pattern="$1"

    local pids="$(pgrep -d , -f "$pattern")"
    if test -n "$pids"; then
        psc -p "$pids" $ps_args
    else
        error "No processes matching $pattern"
    fi
}

# like psgrep, but taking a process group number
psgrepgroup()
{
    # last arg is pgid, rest are args for ps
    local ps_args
    while test $# -gt 1; do
        ps_args="$ps_args $1"
        shift
    done

    local pgid="$1"

    local pids="$(pgrep -d , -g "$pgid")"
    if test -n "$pids"; then
        psc -p "$pids" $ps_args
    else
        error "No processes in process group $pgid"
    fi
}

# print the absolute path of the directory containing the specified file
realdir() {
    dirname "$(readlink -f "$1")"
}

# show the most recently changed files
# defaults to the showing the last 10, override with -<number>
recent()
{
    local lines

    lines=10
    case "$1" in -*)
        lines=${1#-}
        shift
        ;;
    esac
    ls -t -1 "$@" | head -n $lines
}

# keep trying a command until it works
# (e.g. retry ping -c 1 host)
retry()
{
    while true; do
        if "$@"; then
            bell
            break
        else
            sleep 10
        fi
    done
}

# remove the ssh known host from the specified line number
rmkey() {
    delline "$1" "$HOME/.ssh/known_hosts"
}

# run a command with the first argument moved to the end
# e.g. first_arg_last grep ~/.history <args> runs grep <args> ~/.history
first_arg_last() {
    local command
    local arg
    command=$1
    arg=$2
    shift 2
    "$command" "$@" "$arg"
}

# convert a time from one timezone to another
# tz2tz <from timezone> <to timezone> <date spec>
tz2tz() {
    local from="$1"
    local to="$2"
    shift 2
    TZ="$to" date -d 'TZ="'"$from"'"'" $*"
}


# convert from UTC to local time
utc2() {
    date -d 'TZ="UTC" '"$1"
}

# print the definition of the given command, alias, or function
what() {
    if is_zsh; then
        whence -f "$1"
    elif is_bash; then
        case "$(type -t "$1")" in function)
            typeset -f "$1";;
        *)
            command -v "$1";;
        esac
    else
        type "$1"
    fi
}

##################################
# ENVIRONMENT SETUP FOR ALL SHELLS
# Set $PATH early in case other stuff here needs it.

CDPATH=".:$HOME"
GOPATH="$HOME"
export GOPATH

add_path "$HOME/android-sdk-linux/platform-tools"
add_path "$HOME/bin" start
add_path "$GOPATH/bin" start
add_path "$HOME/scripts" start
# scripts.home, scripts.work, etc. override scripts
for dir in "$HOME"/scripts.*; do
    add_path "$dir" start
done
for dir in /opt/*/bin; do
    add_path "$dir" end
done
add_path /sbin end
add_path /usr/sbin end

# set HISTORY_FILE for log_history
HISTORY_FILE=$HOME/.history

export LESS="-R"
if test -f "$HOME/scripts/lessopen"; then
    export LESSOPEN="|$HOME"'/scripts/lessopen "%s"'
fi

#########################
# INTERACTIVE SHELL SETUP
# Set up the prompt, title, key bindings, etc.

if is_interactive; then

    log_history "New session as $USERNAME: $0 $*"

    # regain use of Ctrl+S and Ctrl+Q
    stty start undef stop undef

    # determine the graphics mode escape sequences
    color=false
    if is_command tput; then
        if quiet tput longname; then
            bold="$(tput bold)"
            underline="$(tput smul)"
            standout="$(tput smso)"
            normal="$(tput sgr0)"
            black="$(tput setaf 0)"
            red="$(tput setaf 1)"
            green="$(tput setaf 2)"
            yellow="$(tput setaf 3)"
            blue="$(tput setaf 4)"
            magenta="$(tput setaf 5)"
            cyan="$(tput setaf 6)"
            white="$(tput setaf 7)"
            color=true

            khome="$(tput khome)"
            kend="$(tput kend)"
            kdch1="$(tput kdch1)"
        fi
    fi

    # determine the window title escape sequences
    case "$TERM" in
    aixterm|dtterm|putty|rxvt|xterm*)
        titlestart=']0;'
        titlefinish=''
        ;;
    cygwin)
        titlestart='];'
        titlefinish=''
        ;;
    konsole)
        titlestart=']30;'
        titlefinish=''
        ;;
    screen*)
        # status line
        #titlestart='^[_'
        #titlefinish='^[\'
        # window title
        titlestart='k'
        titlefinish='\'
        ;;
    *)
        if is_command tput; then
            if quiet tput longname; then
                titlestart="$(tput tsl)"
                titlefinish="$(tput fsl)"
            fi
        else
            titlestart=''
            titlefinish=''
        fi
        ;;
    esac

    # prevent running "exit" if the user is still running jobs in the background
    # the user is expected to close the jobs or disown them
    _exit()
    {
        case $- in *m*)
            # this way works in bash and zsh
            jobs | wc -l | grep -q '^ *0 *$'
            if test $? -eq 0; then
                    command exit "$@"
            else
                jobs
            fi
                    ;;
        *)
            command exit "$@"
            ;;
        esac
    }

    path_or_empty() {
        local pathname
        pathname=$(command -v $1)
        if test -e "$pathname"; then
            echo "$pathname"
        else
            echo
        fi
    }

    #alias '?'='path_or_empty'
    alias @='path_or_empty'
    alias bindkeys='pkill xbindkeys; (setsid xbindkeys&)'
    code_patterns="{*.c,*.h,*.cc,*.coffee,*.go,*.java,*.js,*.pl,*.py,*.sh,*.rb,*.swig,*.ts}"
    code_includes="$(eval echo --include=$code_patterns)"
    dir_patterns="{.git,.hg,.svn}"
    dir_excludes="$(eval echo --exclude-dir=$dir_patterns)"
    alias c='less -FX'
    alias cdf='cdfile'
    alias cg='rg '"$code_includes"
    alias ct='ctags -R'
    alias cx='chmod +x'
    alias diga='dig +noall +answer +search'
    alias digs='dig +short +search'
    download() { cd "$HOME/Downloads"; wget "$@"; }
    # function rather than an alias so it looks better in the xterm title.
    e() { "${EDITOR:-vim}" "$@"; }
    alias eg='g -E'
    et() {
        local file
        local testfile

        file=$1
        testfile=$(find_test_file "$file")

        vim -O "$file" ${testfile:+"$testfile"}
    }
    alias f='command fg'
    # fg = fgrep, NOTE: not fg = foreground, use 'f' or '%'
    alias fg='g -F'
    alias g='grep -I'
    alias gdb='gdb -q '
    alias gh='first_arg_last grep ~/.history'
    alias h='head'
    alias headers='curl -L -i -sS -o/dev/null -D-'
    alias hms='date +"%H:%M:%S"'
    alias hmsns='date +"%H:%M:%S.%N"'
    alias hosts='getent hosts'
    alias ipy='ipython'
    alias kssh='ssh -o PreferredAuthentications=publickey'
    if is_command l; then
        alias l='l -Kv'
    elif quiet ls --color=auto -v -d /; then
        alias l='ls --color=auto -v'
    else
        alias l='ls'
    fi
    alias l1='l -1'
    alias la='l -a'
    alias latest='recent -1'
    alias lc='l -C'
    # lg = line grep
    alias lg='g -F'
    alias ll='l -l'
    if quiet l -T; then
        alias lt='l -Tt'
    else
        alias lt='ll -t'
    fi
    alias j='jobs'
    alias m='make'
    # shadows magtape command, but who uses that?
    alias mt='make test'
    alias now='date +"%Y-%m-%dT%H:%M:%S"'
    alias nowns='date +"%Y-%m-%dT%H:%M:%S.%N"'
    # function rather than an alias so it looks better in the xterm title.
    p() { "${PAGER:-more}" "$@"; }
    alias phup='pkill -HUP'
    alias popd='popd >/dev/null'
    alias psg='psgrep'
    alias psgg='psgrepgroup'
    alias psu='ps -o user,pid,start,time,pcpu,stat,cmd'
    alias pushd='pushd >/dev/null'
    alias pd='pushd'
    alias po='popd'
    alias pssh='ssh -o PreferredAuthentications=keyboard-interactive,password'
    alias py='python'
    alias r='fc -e - --'
    alias rg='g -IR '"$dir_excludes"
    alias s='ssh'
    alias spell='aspell -a'
    alias sr='ssh -l root'
    alias symlink='ln -s'
    alias t='tail'
    alias tf='t -f'
    alias tl='t -f /var/log/syslog'
    alias today='date +"%Y-%m-%d"'
    alias ts='t -f /var/log/syslog'
    alias view='vim -R -c ":set mouse="'
    alias v='view'
    alias vl='view /var/log/syslog'
    alias x='_exit'
    xa() { while command fg; do :; done; _exit; }
    alias xr='DISPLAY=:0.0 xrandr'
    alias I='make install'
    alias M='make'
    alias T='make test'

    # expand aliases after nohup, etc.
    for wrapper in nohup strace sudo; do
        alias $wrapper="$wrapper "
    done

    # in case root isn't available, fall back to sudo
    is_command root && alias root="root " || alias root="sudo "

    # enable colors in commands that support it
    # (ls is done above)
    quiet grep -q --color=auto "" /etc/hosts && alias grep='grep --color=auto'
    export CLICOLOR=true

    # allow running git subcommands without typing the "git" prefix
    # TODO: Write a script that supports multiple version control systems,
    # and make it an alias for that instead?
    for command in ad add addall added addremove adds am amend an ap apply \
        blame br checkout changed changes cherry-pick ci cl clone co \
        commit commitall describe da di diffs \
        fetch ff format-patch gc gr graph hi hist history \
        lo log logs ls-files ls-tree \
        merge merge-base pick pu pull push \
        rebase remote remove reset restore rewind rollback \
        show-branch st staged stash state status switch \
        tag track unadd unchange unchangeall undo undoall untrack
    do
        alias $command="git $command"
    done
    # same for my aliases in ~/.gitconfig
    # for command in $(git config -l |
    #     sed -ne '/^alias\./{s/^alias\.\([^ =]*\)=.*/\1/;p}')
    # do
    #     alias $command="git $command"
    # done
    # can't override it using git aliases, so do it here :-/
    alias stage="git add --update"

    alias ginfo=$(path info)
    # aliases to abstract away differences between package managers
    if is_command yum; then
        alias yum='root yum --cacheonly'
        alias update='root yum makecache'
        alias search='yum search'
        alias show='yum info'
        alias install='root yum install'
        alias installed='rpm -qa'
        alias uninstall='root yum erase'
        alias reinstall='root yum reinstall'
        alias upgrade='root yum upgrade'
        alias versions='yum list'
        alias changelog='repoquery --changelog'
        alias files='repoquery --file'
    elif is_command aptitude; then
        alias update='root aptitude -q -q update'
        alias search='aptitude search -F "%c %p %30t %d"'
        alias show='aptitude show'
        alias install='root aptitude install'
        alias installed='dpkg-query --show'
        alias uninstall='root aptitude remove'
        alias reinstall='root aptitude reinstall'
        alias upgrade='root aptitude safe-upgrade'
        alias versions='aptitude versions'
        alias changelog='aptitude changelog'
        alias files='apt-file search'
    elif is_command apt-get; then
        alias update='root apt-get update'
        alias search='apt-cache search --names-only'
        alias show='apt-cache show'
        alias install='root apt-get install'
        alias installed='dpkg-query --show'
        alias uninstall='root apt-get remove'
        alias reinstall='root apt-get install --reinstall'
        alias upgrade='root apt-get upgrade'
        alias versions='apt-cache policy'
        alias changelog='apt-get changelog'
        alias files='apt-file search'
    else
        error "No supported package manager found"
    fi

    # make +<num> change directories and %<num> resume jobs
    # this matches the first column in the prompt output
    case "$shell" in
    bash|zsh)
        # use legacy function syntax then alias to prevent dash syntax errors,
        # which could cause X session errors on Debian/Ubuntu
        plus() {
            pushd "$@" >/dev/null
        }
        minus() {
            popd "$@" >/dev/null
        }
        plusminus() {
            pushd "$OLDPWD" >/dev/null
        }
        pushpop() {
            eval "pushd ~$1" >/dev/null
            popd +$(($1 + 1)) >/dev/null
        }
        alias -- +='plus'
        alias -- -='minus'
        alias -- +-='plusminus'
        for i in $(seq 0 9); do
            alias -- +$i='pushpop '$i
        done
        ;;
    *)
        # ksh and dash lack %, %1, etc.
        alias %='fg'
        for i in $(seq 0 9); do
            alias %$i='fg %'$i
        done
        ;;
    esac

    # set a basic prompt that doesn't rely on precommand and preprompt hooks
    basic_prompt() {
        PS1='$ '
        PS2='_ '
        PS3='#? '
        set_title "$(title)"
    }

    # commands to execute before the prompt is displayed
    preprompt() {
        local last_error="$(${shell}_last_error)"
        current_command=

        printf '\n'
        set_color 'normal'
        if test -n "$last_error"; then
            set_color 'red'
            printf '%s\n' "$last_error"
            set_color 'normal'
        fi
        printf '%s %s\n' "$(host_info)" "$(auth_info)"
        dir_info
        job_info
        set_title "$(title)"
        set_prompt
        flash_terminal
    }

    # for overriding in .shrc.local
    auth_info() {
        :
    }

    # get the user's attention
    flash_terminal() {
        case $TERM in xterm)
            bell
            ;;
        esac
    }

    # return true if the current user is root
    i_am_root() {
        test $UID -eq 0
    }

    # return true if this machine is my laptop
    _on_my_laptop() {
        if test -f "$HOME"/.laptop; then
            true
        else
            case "$HOSTNAME" in
            *laptop*) true;;
            *)        false;;
            esac
        fi
    }

    # return true if this machine is my laptop
    on_my_laptop() {
        if test -z "${LAPTOP:-}"; then
            if _on_my_laptop; then
                LAPTOP=true
            else
                LAPTOP=false
            fi
        fi
        "$LAPTOP"
    }

    # return true if this is a non-production machine I use to get work done
    on_my_machine() {
        on_my_workstation || on_my_laptop
    }

    # return true if this machine is my workstation
    _on_my_workstation() {
        if test -f "$HOME"/.workstation; then
            true
        else
            case "$HOSTNAME" in
            *laptop*)    false;;
            $USERNAME-*) true;;
            *)           false;;
            esac
        fi
    }

    # return true if this machine is my workstation (cached version)
    on_my_workstation() {
        if test -z "${WORKSTATION:-}"; then
            if _on_my_workstation; then
                WORKSTATION=true
            else
                WORKSTATION=false
            fi
        fi
        "$WORKSTATION"
    }

    # return true if this machine is a production machine
    on_production_host() {
        ! on_my_workstation && ! on_my_laptop && ! on_test_host
    }

    # return true if this machine is a test (i.e. non production) machine
    on_test_host() {
        case "$HOSTNAME" in
            *test*) true;;
            *)      false;;
        esac
    }

    # print information about this machine
    host_info() {
        if on_production_host; then
            set_color 'red'
        fi
        printf '%s' "$(short_hostname)"
        set_color 'normal'
        printf '\n'
    }

    # print information about all shell jobs
    # intended to be used in the preprompt
    job_info() {
            jobs |
                sed -e 's/^\[\([0-9][0-9]*\)\][-+ ]*[^ ]* */%\1 /' |
                grep -v '(pwd now:'
    }

    # print directory stack listing in "+<number> <directory>" format
    # intended to be used in the preprompt
    dir_info() {
        if is_zsh; then
            i=0
            for _dir in "$PWD" "${dirstack[@]}"; do
                blue "+$i $(_dir_info "$_dir")"
                echo
                i=$((i+1))
            done
        elif is_bash; then
            i=0
            for _dir in "${DIRSTACK[@]}"; do
                case "$_dir" in
                "~")
                    _dir="$HOME"
                    ;;
                "~"/*)
                    _dir="$HOME/${_dir#\~/}"
                    ;;
                esac
                blue "+$i $(_dir_info "$_dir")"
                echo
                i=$((i+1))
            done
        else
            blue "$PWD"
            echo
        fi
    }
    _dir_info() {
        # if the directory is under version control, print
        # <project name> <subdir under project root> <branch>,
        # otherwise just the directory with $HOME turned into ~
        cd "$1"
        local projectroot="$(projectroot)"
        if test -n "$projectroot"; then
            green "$(basename "$projectroot")"
            local projectsubdir
            projectsubdir="$(trim_prefix "$(projectroot)" "$PWD")"
            if test -n "$projectsubdir"; then
                printf ' '
                blue "$projectsubdir"
            fi
            local branch
            branch="$(branch)"
            if test -n "$branch"; then
                printf ' '
                green "$branch"
            fi
        else
            tilde_directory
        fi
    }

    short_pwd() {
        local projectname="$(projectname)"
        if test -n "$projectname"; then
            printf '%s' "$projectname"
        else
            printf '%s' "$(basename "$PWD")"
        fi
    }

    project_or_command_or_pwd() {
        local projectname="$(projectname)"
        if test -n "$projectname"; then
            printf '%s' "$projectname"
        elif test -n "${current_command:-}"; then
            printf '%s' "${current_command%% *}"
        else
            printf '%s' "$(basename "$PWD")"
        fi
    }

    # print the name of the current branch
    branch() {
        :
    }

    # print the name of all branches
    branches() {
        :
    }

    blue() {
        if $color; then
            printf '%s%s%s' "$blue" "$*" "$normal"
        else
            printf '%s' "$*"
        fi
    }
    green() {
        if $color; then
            printf '%s%s%s' "$green" "$*" "$normal"
        else
            printf '%s' "$*"
        fi
    }

    # print what remote commits would get pulled
    incoming() {
        :
    }

    # print what local commits would get pushed
    outgoing() {
        :
    }

    # print the name of the current project
    projectname() {
        basename "$(projectroot)"
    }

    # print the root directory of the current project
    projectroot() {
        :
    }

    trim_prefix() {
        expr substr "$2" $(expr length "$1" + 2) 9999
    }

    # load all the version control functions (git_*, hg_*, etc.)
    if test -f "$HOME/.shrc.vcs"; then
        . "$HOME/.shrc.vcs"
    fi

    # print a message describing the last error, or empty if no error
    bash_last_error() {
        laststatus=$?
        case $laststatus in
        0)   ;;
        130) echo "Interrupted";;
        148) ;;  # suspended
        *)   echo "Exit status $laststatus";;
        esac
    }

    # print a message describing the last error, or empty if no error
    sh_last_error() {
        laststatus=$?
        case $laststatus in
        0)   ;;
        *)   echo "Exit status $laststatus";;
        esac
    }
    alias ksh_last_error=sh_last_error

    # print a message describing the last error, or empty if no error
    zsh_last_error() {
        laststatus=$?
        case $laststatus in
        0)   ;;
        20)  ;;  # suspended (zsh < 5.0.7)
        130) echo "Interrupted";;
        148) ;;  # suspended (zsh >= 5.0.7)
        *)   echo "Exit status $laststatus";;
        esac
    }

    # get a short version of the hostname for use in the prompt or window title
    short_hostname() {
        local hostname
        local site
        hostname="${HOSTNAME%%.*}"
        hostname="${hostname#$USERNAME-}"
        if ! on_my_machine; then
            sitename="$(short_sitename)"
            if test -n "$sitename"; then
                hostname="$hostname.$sitename"
            fi
        fi
        printf "%s" "$hostname"
    }

    # get a short version of the domain name for use in the prompt etc.
    short_sitename() {
        local sitename
        case "$HOSTNAME" in *.???.*.*)
            sitename="${HOSTNAME#*.}"
            sitename="${sitename%%.*}"
            ;;
        *)
            sitename=
            ;;
        esac
        printf "%s" "$sitename"
    }

    # ssh to remote host using current shell's config
    mssh() {
        # allow passing a single block of options to ssh/scp, e.g. -4
        local ssh_opts=
        case "$1" in -*)
            ssh_opts="$1"
            shift
            ;;
        esac
        case $SHELL in
        *bash) bssh $ssh_opts "$@";;
        *zsh)  zssh $ssh_opts "$@";;
        *)     ssh  $ssh_opts "$@";;
        esac
    }

    # ssh to remote host using this host's bashrc
    bssh() {
        # allow passing a single block of options to ssh/scp, e.g. -4
        local ssh_opts=
        case "$1" in -*)
            ssh_opts="$1"
            shift
            ;;
        esac
        ssh $ssh_opts -t "$@" '
export BASHRC=$(mktemp /tmp/bash.XXXXXXXX);
scp $ssh_opts '"$HOSTNAME:${BASHRC:-.bashrc}"' "$BASHRC";
exec bash --rcfile "$BASHRC" -i'
    }

    # ssh to remote host using this host's zshrc
    zssh() {
        # allow passing a single block of options to ssh/scp, e.g. -4
        local ssh_opts=
        case "$1" in -*)
            ssh_opts="$1"
            shift
            ;;
        esac
        ssh $ssh_opts -t "$@" '
export ZDOTDIR=$(mktemp -d /tmp/zsh.XXXXXXXX);
scp $ssh_opts '"$HOSTNAME:${ZDOTDIR:-$HOME}/.zshrc"' "$ZDOTDIR";
exec zsh -i'
    }

    # print the current directory with $HOME changed to ~
    tilde_directory() {
        printf '%s' "$PWD" | sed -e 's#^'"$HOME"'#~#'
    }

    # trim leading parts of a directory so it's no more than three entries long
    shorten_directory() {
        local dir="$1"

        while expr "$dir" : '.*/.*/.*/.*' >/dev/null; do
            dir=${dir#*/}
        done
        printf '%s' "$dir"
    }

    # print the string that should be used as the xterm title
    title() {
        short_hostname
        printf ' '
        project_or_command_or_pwd
    }

    # set all the prompt strings
    # done this way so that \[ (bash) and \{ (zsh) are handled consistently
    set_prompt() {
        PS1="$(ps1)"
    }

    # output the string that should be used as the prompt
    ps1() {
        ps1_character
        printf ' '
    }

    # print a character that should be the last part of the prompt
    ps1_character() {
        if test $UID -eq 0; then
            printf '#'
        elif test "${keymap:-}" = 'vicmd'; then
            printf '>'
        else
            printf '$'
        fi
    }

    # print a character indicating whether vi command mode is active
    keymap_character() {
        case "${keymap:-}" in vicmd)
            printf '%s' '>'
            ;;
        *)
            printf ' '
            ;;
        esac
    }

    # function to run just before running a command from the command line
    # see also preexec (zsh) and DEBUG (bash)
    # the first argument is the command line being run
    precommand() {
        log_history "$*"
        current_command="$(expand_job "$*")"
        set_title "$(title)"
        set_color 'normal'
    }

    # set the xterm title to the supplied string
    set_title() {
        if test -n "$titlestart"; then
            printf "%s%s%s" "$titlestart""$*""$titlefinish"
        fi
    }

    # expand job references such as %1 into the command name
    expand_job() {
        local arg

        test $# -eq 0 && return

        arg=$1
        shift

        case "$arg" in f|fg)
            arg='%+'
            ;;
        esac
        case "$arg" in '%'*)
            # can't use job_info here in bash
            arg="$(jobs "$arg" | sed -e 's/^\[[0-9][0-9]*\][-+ ]*[^ ]* *//')"
            ;;
        esac
        printf '%s' "$arg" "$@"
    }

    # print the supplied string inside prompt escape sequences
    # that tell the shell the escape sequences do not move the cursor
    prompt_color() {
        local color_escape

        color_escape=$(set_color "$*")

        if test -n "$color_escape" && test -n "$escape_start" && test -n "$escape_end"; then
            printf '%s%s%s' "$escape_start" "$normal" "$escape_end"
            printf '%s%s%s' "$escape_start" "$color_escape" "$escape_end"
        fi
    }
    # set the terminal color to the specified color or terminal attribute
    # accepts multiple arguments, e.g. set_color bold blue underline
    set_color() {
        local arg

        for arg; do
            eval "printf \"%s\" \"\$$arg\""
        done
    }
    escape_start=
    escape_end=

    terminal_supports_bracketed_paste() {
        case $TERM in rxvt-unicode|xterm)
            true;;
        *)
            false;;
        esac
    }

    enable_bracketed_paste() {
        if terminal_supports_bracketed_paste; then
            printf '\e[?2004h'
        fi
    }

    disable_bracketed_paste() {
        if terminal_supports_bracketed_paste; then
            printf '\e[?2004l'
        fi
    }

    case "$shell" in
    zsh)
        # zsh enhancements
        setopt AUTO_CD
        setopt CORRECT
        setopt DVORAK
        setopt EXTENDED_GLOB
        setopt PROMPT_PERCENT
        setopt PUSHD_SILENT

        # fall back to case-insensitive completion if there's no exact match
        zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}'

        # user input appears in bold
        declare -a zle_highlight
        zle_highlight[0]="default:bold"

        escape_start='%{'
        escape_end='%}'

        # install preprompt and precommand functions
        enable_prompt_hooks() {
            precmd() {
                preprompt
            }
            preexec() {
                precommand "$1"
            }
        }
        disable_prompt_hooks() {
            unset -f precmd
            unset -f preexec
            basic_prompt
        }
        enable_prompt_hooks

        # use underscores in the function names so dash doesn't choke
        zle_keymap() {
            emulate -L zsh
            keymap=$KEYMAP
            set_prompt
            zle reset-prompt
            zle -R
        }
        zle_line_init() {
            zle_keymap
            enable_bracketed_paste
        }
        zle_keymap_select() {
            zle_keymap
        }
        zle_line_finish() {
            zle_keymap
            disable_bracketed_paste
        }
        zle -N zle-line-init zle_line_init
        zle -N zle-keymap-select zle_keymap_select
        zle -N zle-line-finish zle_line_finish

        # make Home, End, and Delete keys work
        _terminfo_bind() {
            if test -n "${terminfo[$1]:-}"; then
                bindkey -M emacs "${terminfo[$1]}" "$2"
                bindkey -M viins "${terminfo[$1]}" "$2"
                bindkey -M vicmd "${terminfo[$1]}" "$2"
            fi
        }
        _terminfo_bind kdch1 delete-char
        _terminfo_bind khome beginning-of-line
        _terminfo_bind kend end-of-line

        # prevent PageUp and PageDown from inserting a bogus ~
        zle_noop() { :; }
        zle -N zle-noop zle_noop
        _terminfo_bind knp zle-noop
        _terminfo_bind kpp zle-noop

        # standardize Ctrl+U behavior
        bindkey -M viins '^u' kill-whole-line
        bindkey -M vicmd '^u' kill-whole-line

        # Make Esc toggle between command and insert mode
        bindkey -M vicmd '\e' vi-insert

        # add Emacs bindings to Vi editing mode
        _bind_vi() {
            bindkey -M viins "$@"
            bindkey -M vicmd "$@"
        }
        _bind_vi '^a' beginning-of-line
        _bind_vi '^e' end-of-line
        _bind_vi '^n' down-line-or-history
        _bind_vi '^p' up-line-or-history
        _bind_vi '^r' history-incremental-search-backward
        _bind_vi '^s' history-incremental-search-forward
        _bind_vi '^w' backward-kill-word
        _bind_vi '^y' yank
        _bind_vi '\eb' backward-word
        _bind_vi '\eB' vi-backward-blank-word
        _bind_vi '\ef' forward-word
        _bind_vi '\eF' vi-forward-blank-word
        _bind_vi '\ey' yank-pop

        # try to differentiate between Esc vi command and Alt+something
        KEYTIMEOUT=1

        # enable support for xterm bracketed paste

        # switch to the paste keymap
        start_paste() {
            bindkey -A main previous
            bindkey -A paste main
        }
        # strip a single final newline and switch back to the previous keymap
        end_paste() {
            LBUFFER="${LBUFFER%
}"
            bindkey -A previous main
        }
        # associate the bindkey widgets with the corresponding functions
        zle -N start-paste start_paste
        zle -N end-paste end_paste
        # .safe is self-insert except for ^J and ^M
        bindkey -N paste .safe
        # make newlines not act like Enter
        # (have it insert a newline, not do accept-line)
        bindkey -M paste '^J' self-insert
        # make pasted newlines appear as newlines
        # (terminal sends ^M but zsh wants ^J)
        bindkey -M paste -s '^M' '^J'
        # start pasting when seeing the start escape sequence
        bindkey -M emacs '^[[200~' start-paste
        bindkey -M viins '^[[200~' start-paste
        bindkey -M vicmd '^[[200~' start-paste
        # end pasting when seeing the finish escape sequence
        bindkey -M paste '^[[201~' end-paste
        # translate some hard-to-spot Unicode characters to ASCII
        bindkey -M paste -s '“' '"'
        bindkey -M paste -s '”' '"'
        bindkey -M paste -s '…' '...'
        bindkey -M paste -s ' ' ' '

        ;;
    bash)
        # bash enhancements
        shopt -s autocd
        shopt -s checkwinsize
        shopt -s lithist

        escape_start='\['
        escape_end='\]'

        # install preprompt and precommand functions
        # the DEBUG trap is disabled during running of preprompt to avoid lots
        # of extra processing and several pointless title changes
        install_precommand_trap() {
            trap 'precommand "$BASH_COMMAND"; remove_precommand_trap' DEBUG
            set_title "$(title)"
        }
        remove_precommand_trap() {
            trap - DEBUG
        }
        enable_prompt_hooks() {
            PROMPT_COMMAND='preprompt; install_precommand_trap'
        }
        disable_prompt_hooks() {
            remove_precommand_trap
            PROMPT_COMMAND=
            basic_prompt
        }
        enable_prompt_hooks

        # these key bindings should be kept in sync with ~/.inputrc
        # they are duplicated here so scp ~/.shrc newhost: is sufficient

        _bind_vi() {
            bind -m vi-command "$@"
            bind -m vi-insert "$@"
        }

        _bind_emacs() {
            bind -m emacs "$@"
        }

        _bind_all() {
            _bind_emacs "$@"
            _bind_vi "$@"
        }

        # make motion commands treat all non-space characters as word chars
        _bind_emacs '"\eb": vi-bWord'
        _bind_emacs '"\ef": vi-fWord'
        _bind_emacs '"\eB": vi-bWord'
        _bind_emacs '"\eF": vi-fWord'
        _bind_emacs '"\ed": shell-kill-word'
        _bind_emacs '"\eD": shell-kill-word'
        _bind_all '"\e\C-?": unix-word-rubout'

        # prevent Page Up and Page Down from inserting a bogus ~
        # TODO: use terminfo
        # TODO: double check tty-status is a sane thing
        _bind_all '"\e[5~": tty-status'
        _bind_all '"\e[6~": tty-status'

        # standardize Ctrl+U behavior
        _bind_all '"\C-u": kill-whole-line'

        # add Emacs bindings to Vi editing mode
        _bind_vi '"\C-a": beginning-of-line'
        _bind_vi '"\C-e": end-of-line'
        _bind_vi '"\C-n": next-history'
        _bind_vi '"\C-p": previous-history'
        _bind_vi '"\C-r": reverse-search-history'
        _bind_vi '"\C-s": forward-search-history'
        _bind_vi '"\C-w": backward-kill-word'
        _bind_vi '"\C-y": yank'
        _bind_vi '"\eb": vi-bWord'
        _bind_vi '"\eB": vi-bWord'
        _bind_vi '"\ef": vi-fWord'
        _bind_vi '"\eF": vi-fWord'
        _bind_vi '"\ey": yank-pop'

        # Make Esc toggle between command and insert mode
        bind -m vi-command '"\e": vi-insertion-mode'
    esac

    # set up per-package tab completion
    case "$shell" in bash|zsh)
        # define "have", used by some scripts in /etc/bash_complete.d/*
        have() {
            unset have
            if type "$1" >/dev/null 2>&1; then
                have=yes
                true
            else
                false
            fi
        }

        # /etc/bash_completion doesn't work in zsh, but most of the scripts
        # under /etc/bash_completion.d do.  silence the output to ignore the
        # ones that don't.
        for f in /etc/bash_completion.d/*; do
            source "$f" >/dev/null 2>&1
        done
        ;;
    esac

    # set a simple prompt for non-bash non-zsh
    # (will be overridden immediately by bash and zsh)
    basic_prompt
    alias _=' '

    # program defaults
    export BLOCKSIZE=1024
    export GREP_COLOR=4

    # default programs
    is_command vi && EDITOR=vi
    is_command vim && EDITOR=vim
    is_command more && PAGER=more
    is_command less && PAGER=less

    # colors for ls
    case "$TERM" in linux|putty|vt220)
        # colors for white on black
        export LSCOLORS='ExFxxxxxCxxxxx'
        export LS_COLORS='no=00:fi=00:di=01;34:ln=01;35:so=00;00:bd=00;00:cd=00;00:or=01;31:pi=00;00:ex=01;32'
        ;;
    *)
        # colors for black on white
        export LSCOLORS='exfxxxxxcxxxxx'
        export LS_COLORS='no=00:fi=00:di=00;34:ln=00;35:so=00;00:bd=00;00:cd=00;00:or=00;31:pi=00;00:ex=00;32'
        ;;
    esac

    # command line editing
    test -r "$HOME"/.inputrc && export INPUTRC="$HOME"/.inputrc
    set -o emacs

    # workaround for GNOME Terminal which does a cd on startup :-(
    if test -n "${DISPLAY:-}" && test -z "${didcd:-}"; then
        # assuming DISPLAY=:0.0 means local
        # note that DISPLAY=localhost:0.0 can mean SSH X forwarding
        case "${DISPLAY:-}" in :*)
            cd
            didcd=true
            ;;
        esac
    fi
fi

# source local overrides file (work vs home, etc.)
test -f "${ZDOTDIR:-$HOME}/.shrc.local" && . "${ZDOTDIR:-$HOME}/.shrc.local"

# finish with a zero exit status so the first prompt is '$' rather than '?'
true

# Use tabs for indentation so we can edit this in nvi if necessary.
# vi: set sw=4 ts=33:
# vim: set ft=sh:
