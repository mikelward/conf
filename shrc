#!/bin/sh
#
# Configuration for bash, zsh, ksh, dash, etc.
#
# Configuration for all shells is in this one file so that it can be easily
# copied to many hosts.
#
# bashrc and zshrc should be symlinks to this file.
#
# ksh and dash should also work, but will have a simpler prompt, etc.
#
# This file can't use arrays, the (( )) form of arithmetic expansion,
# herestrings, or anything that causes a parse error in sh or dash.
# Note that the $(( )) form of arithmetic expansion appears to be OK.
#
# Mikel Ward <mikel@mikelward.com>
#

###############
# COMPATIBILITY
# Try to make all shells behave similarly while reading this file

is_zsh() {
    [ -n "${ZSH_VERSION:-}" ]
}

is_bash() {
    [ -n "${BASH_VERSION:-}" ]
}

is_ksh() {
    [ -n "${KSH_VERSION:-}" ]
}

if is_zsh; then
    shell=zsh
elif is_bash; then
    shell=bash
elif is_ksh; then
    shell=ksh
else
    shell=sh
fi

case "$shell" in
zsh)
    # make zsh as similar to bash as possible
    emulate sh
    setopt BRACE_EXPAND
    setopt BANG_HIST
    setopt CSH_JUNKIE_HISTORY
    setopt INTERACTIVE_COMMENTS
    setopt KSH_TYPESET
    # so aliases can contain hyphen/minus/dash
    unsetopt POSIX_ALIASES >/dev/null 2>&1
    # so we can display jobs in the prompt
    unsetopt POSIX_JOBS >/dev/null 2>&1

    # share history between shells
    # particularly useful for zsh-autocomplete
    setopt SHARE_HISTORY
    HISTFILE=~/.zsh_history
    HISTSIZE=5000
    SAVEHIST=5000

    # make tab completion do what it says
    # e.g. in conf/config, i3s<TAB> completes to i3status/, it should
    # autocd to i3status/, not strip the slash and run i3status
    unsetopt AUTO_REMOVE_SLASH

    # set_prompt sets PS1 to a string likely including '$', don't expand it
    unsetopt PROMPT_SUBST

    # enable ksh default features
    setopt KSH_GLOB         # !(pattern) etc. like in ksh
    unsetopt BARE_GLOB_QUAL # otherwise !(pattern) breaks

    # zsh-style autoload, required for e.g. bashcompinit
    unsetopt KSH_AUTOLOAD

    # allow numeric glob (and incidentally, grouping of globs inside parens)
    unsetopt SH_GLOB
    ;;
bash)
    # set_prompt sets PS1 to a string likely including '$', don't expand it
    shopt -u promptvars

    # enable ksh default features
    shopt -s extglob        # !(pattern) etc. like in ksh

    # enable zsh default features
    shopt -s globstar       # recursive globbing with **
    ;;
ksh)
    alias local=typeset
    ;;
esac

# standardize on bash-like variables that everyone assumes are preset
: ${USERNAME:=$(id -un)}
: ${HOSTNAME:=$(hostname --fqdn)}
: ${UID:=$(id -u)}
: ${TTY:=$(tty)}

#######
# PATH FUNCTIONS
# Functions used to modify $PATH
#
prepend_path() {
  local _dir=$1
  test -d "$_dir" || return
  delete_path "$_dir"
  if test -n "$PATH"; then
    PATH="$_dir:$PATH"
  else
    PATH="$_dir"
  fi
}

append_path() {
  local _dir=$1
  test -d "$_dir" || return
  delete_path "$_dir"
  if test -n "$PATH"; then
    PATH="$PATH:$_dir"
  else
    PATH="$_dir"
  fi
}

delete_path() {
  local _dir=$1
  PATH=$(
    _newpath=
    IFS=:
    for dir in $PATH; do
      if test "$dir" != "$_dir"; then
        _newpath=${_newpath:+$_newpath:}$dir
      fi
    done
    printf '%s' "$_newpath"
  )
}

inpath() {
  local _dir=$1
  (
    IFS=:
    for dir in $PATH; do
      if test "$dir" = "$_dir"; then
        return 0
      fi
    done
    return 1
  )
}

add_path() {
  local _dir=$1
  local _where=$2
  local _newpath=$PATH

  case "$_where" in start|end)
    delete_path "$_dir" "$_newpath"
    case "$_where" in
    start)
      prepend_path "$_dir" "$_newpath"
      ;;
    end)
      append_path "$_dir" "$_newpath"
      ;;
    esac
    ;;
  *)
    if ! inpath "$_dir"; then
      append_path "$_dir"
    fi
    ;;
  esac
}

#################
# BASIC FUNCTIONS
# Functions that are needed elsewhere in this file.

# hook for authenticating (to ssh-agent, etc.)
alias a=auth
auth() {
    ssh-add
}

# hook for printing which things I need to authenticate to (ssh-agent, etc.)
auth_info() {
    local problems=""
    is_ssh_valid || problems="$problems SSH"
    test -n "$problems" && yellow "${problems# }"
}

# ask the user whether to do something, return true if they say yes or Enter
confirm() {
    printf "$*? [Y/n]"
    read REPLY
    case "$REPLY" in
        [Yy]|'')
            true;;
        *)
            false
            ;;
    esac
}

# returns whether an SSH key is loaded
is_ssh_valid() {
    ssh-add -L >/dev/null 2>&1
}

# returns whether I need to authenticate
need_auth() {
    test -n "$(auth_info)"
}

# return true if this machine is my workstation
workstation() {
    # cache null result too.
    if test "${WORKSTATION-unset}" = "unset"; then
        WORKSTATION="$(cat "$HOME"/.workstation 2>/dev/null)"
    fi
    echo "$WORKSTATION"
}

# return true if this machine is my workstation
on_my_workstation() {
    case "$HOSTNAME" in
        "$(workstation)") true;;
        *laptop*)          false;;
        $USERNAME-*)       true;;
        *)                 false;;
    esac
}

# print an error message
error() {
    printf "$*\n" >&2
}

# return true if the argument is a shell builtin that can be invoked
is_builtin() {
    case "$(type "$1")" in *" shell builtin")
        true
        ;;
    *)
        false
        ;;
    esac
}

# return true if the argument is an alias
is_alias() {
    alias "$1" >/dev/null 2>&1
}

# return true if running the argument would run a command (and not an alias)
is_command() {
    test -x "$(command -v "$1")"
}

# return true if the argument exists as a command, bypassing aliases
have_command() {
    path "$1" >/dev/null 2>&1
}

# return true if the argument is an alias, builtin, command, or function
is_runnable() {
    type "$1" >/dev/null 2>&1
}

# return true if the shell is interactive
is_interactive() {
    case $- in *i*)
        true
        ;;
    *)
        false
        ;;
    esac
}

# log the running of a command to a file
log_history() {
    printf '%s\n' "$(date "+%Y%m%d %H%M%S %z") $TTY $*" >> "$HISTORY_FILE"
}

# run a command with output silenced
quiet() {
    "$@" >/dev/null 2>&1
}

# run a command, or just print what would be run if SIMULATE is true
run() {
    if ${SIMULATE:-false}; then
        echo "Would run $*"
    else
        logger -p user.info "Running $*"
        "$@"
    fi
}

# print an important message that's not quite an error
warn() {
    printf "$*\n" >&2
}

###################
# GENERAL FUNCTIONS
# Useful things that could be commands if distributing them wasn't impractical.

# print the age of a file in seconds
age() {
    local mtime="$(stat -c '%Y' "$1")"
    expr "$(date +%s)" - "$mtime"
}

# look up a hostname in DNS, output both A and AAAA records
addr() {
    dig +noall +answer +search "$1" a "$1" aaaa | get_address_records
}

ptr() {
    dig +noall +answer -x "$1" ptr | get_ptr_records
}

# read BIND-style DNS entries, print the A and AAAA records
get_address_records() {
    awk '$3 == "IN" && $4 ~ /^A/ { print $5 }'
}

# read BIND-style DNS entries, print the PTR records
get_ptr_records() {
    awk '$3 == "IN" && $4 == "PTR" { print $5 }'
}

with_address_records() {
    local hostname
    while read -r hostname; do
        echo "$hostname $(join " " $(addr $hostname))"
    done
}

with_hostnames() {
    local ip
    while read -r ip; do
        echo "$ip $(join " " $(ptr $ip))"
    done
}

# list this machine's IP addresses
ips() {
    ip -o a sh up primary scope global | while read num iface afam addr rest; do
      case "$afam" in inet*)
          echo $iface $addr;;
      esac
    done
}
alias addrs=ips

# list this machine's MAC addresses
# format: <iface> <MAC addr>[\n<iface> <MAC addr>]*
macs() {
    ip -s l sh | sed -n '
/^[0-9][0-9]*:/{
s/^[0-9][0-9]*: \([^:]*\).*/\1/
h
}
/^    link\/ether/{
s/^    link\/ether \([^ ]*\).*/ \1/
H
x
s/\n//
p
}
'
}

bak() {
    local file
    for file in "$@"; do
        mv -i "$file" "${file}.bak"
    done
}

unbak() {
    local file
    for file in "$@"; do
        test -e "$file" && mv -i "$file" "${file%.bak}"
        test -e "${file}.bak" && mv -i "${file}.bak" "$file"
    done
}

excd() {
    local dir
    dir="${1%.*}"
    aunpack --extract-to="$dir" "$1"
    cd "$dir"
}

# ring the terminal's bell
bell() {
    printf "\a"
}

# print the first line of input (the header) as-is, run a command
# on the rest the input (the body)
# e.g. ps | body grep ps
#
# accepts an option -<number>, makes the header <number> lines
# instead of 1
# e.g. netstat -tn | body -2 grep ':22\>'
body() {
    local lines

    lines=1
    case "$1" in -*)
        lines=${1#-}
        shift
        ;;
    esac

    while test $lines -gt 0; do
        IFS= read -r header
        printf '%s\n' "$header"
        lines=$((lines-1))
    done
    "$@"
}

# print the path from buildroot to $PWD
builddir() {
    local buildroot=$(buildroot)
    if test "$PWD" = "$buildroot"; then
        echo "."
    else
        echo "${PWD#$(buildroot)/}"
    fi
}

# print the directory that builds are relative to
buildroot() {
    projectroot
}

# print the name of the current project
projectname() {
    basename "$(projectroot)"
}

# print the root directory of the current project
projectroot() {
    :
}

# cd to the real directory that the specified file is in, resolving symlinks
cdfile() {
    cd "$(realdir "$1")"
}

delline() {
    sed -i -e ${1}d "$2"
}

# print the block device associated with the given mount point (or file)
dev() {
    df -Pk "$1" | while read fs blocks used avail cap mount; do
        case "$mount" in /*)
            echo "$fs"
        esac
    done
}

#mounts() {
#    declare -a nodevs
#    nodev=( $(</proc/filesystems awk '$1 ~ /^nodev$/ { print $2 }') )
#    local IFS=,
#    findmnt -t nosquashfs,"${nodevs[*]}"
#}

# run a command on each line of stdin
each() {
  local _line
  while IFS=$'\n' read -r _line; do
    "$@" "$_line"
  done
}

# run a command on each null-delimited parameter from stdin
each0() {
  local _arg
  while IFS= read -d '' -r _arg; do
    "$@" "$_arg"
  done
}

# see what changes a command would make to a file
# e.g. trydiff mdformat <file>
trydiff() {
    local _temp
    _temp="$2".trydiff.$$
    "$1" "$2" >"$_temp"
    diff "$2" "$_temp"
    rm "$_temp"
}

# apply the changes that trydiff would have made
# e.g. applydiff mdformat <file>
applydiff() {
    "$1" "$2" >"$2".new
    mv "$2".new "$2"
}

# print the name of a source file's corresponding test file
find_test_file() {
    local file
    local dir
    local base
    local ext
    local testfile

    file=${1##*/}
    dir=${1%$file}
    base=${file%.*}
    ext=${file#$base}

    testfile=${dir:+$dir/}${base}_test$ext
    [ -e "$testfile" ] && printf '%s' "$testfile"
}

# search for a file in parent directories, print the first one found
find_up() {
    (
        while true; do
            if test -f "./$1"; then
                echo "$PWD/$1"
                return 0
            fi
            if test "$PWD" = "/"; then
                return 1
            fi
            cd .. || return 1
        done
    )
}

# replace a file with a sorted version of itself
isort() {
    sort "$1" >"$1".bak
    mv "$1".bak "$1"
}

# join the arguments list by inserting a character between each element
# the first argument is the separator, the rest are the words to join
join() {
  (
    IFS=$1
    shift
    echo "$*"
  )
}

# make a directory and cd to it
mcd() {
    if test -d "$1"; then
        printf "%s already exists\n" "$1"
    else
        mkdir -p "$1" && cd "$1"
    fi
}

# make a temporary directory and cd to it
mtd() {
    cd "$(mktemp -d)"
}

# unpack a zipfile to a directory and cd to the extracted directory
ucd() {
    local _temp
    _temp="$(mktemp -p "$PWD")"
    aunpack --save-outdir="$_temp" "$1"
    local _outdir="$(cat "$_temp")"
    test -d "$_outdir" || return 1
    cd "$_outdir"
    rm "$_temp"
}

# get this machine's public IP address as seen by Google
myip() {
    dig +short o-o.myaddr.l.google.com txt @ns1.google.com | tr -d '"'
}

# print the list of nameservers
names() {
    sed -ne '/^nameserver/{s/^nameserver[[:space:]]*//;p}' /etc/resolv.conf
    nmcli dev list 2>/dev/null | sed -ne '/domain_name_servers/{s/[^ ]*: *//;p}'
    nmcli dev show 2>/dev/null | sed -ne '/^IP..DNS/{s/[^ ]*: *//;p}'
}

# list non-empty files, prefixed by timestamp in case sorting is needed
nonempty() {
    find . -size +0 "$@" -printf '%T@ %f\n'
}

# print the full path to an executable, ignoring aliases and functions
# like whence -p/type -P, but should work in all shells
path() {
    (
        IFS=:
        for d in $PATH; do
            if test -x "$d/$1"; then
                echo "$d/$1"
                return
            fi
        done
        false
    )
}

# update config files
pc() {
    for d in "$HOME/conf" "$HOME/conf".* "$HOME/scripts" "$HOME/scripts".*; do
        cd "$d" || continue
        pull || break
        if test -f ".gitmodules"; then
            git submodule init
            git submodule update
        fi
    done
}

# list processes in the specified process group
# pgroup <pgid> [<pgrep args>]
pgroup() {
    pgrep -g "$@"
}

# grep for a pattern in the environments of processes matching the given pattern
# pegrep <environment pattern> <process pattern>
# e.g. pegrep SSH_AUTH_SOCK xfce4
pegrep() {
    for pid in $(pgrep -f "^$2"); do
        printf '%s %s\n' "$(ps -o pid= -o args= -p $pid)" "$(envgrep "$1" $pid)"
    done
}
alias peg=pegrep

# grep for a pattern in the environment of processes with the given pids
# envgrep <environment pattern> <pid>...
envgrep() {
    local pattern
    local pid
    pattern="$1"
    shift
    for pid in "$@"; do
        grep -z "$pattern" /proc/$pid/environ
    done
}

# ps with useful default options
psc() {
    # user,pid,ppid,pgid,start_time,pcpu,rss,comm are first, followed by any -o option
    # the user supplies, then args are last.
    ps -w -o user,pid,ppid,pgid,start_time,pcpu,rss,comm=EXE "$@" -o args=ARGS
}

# pgrep with default ps options
# psgrep [<ps options>] <pattern>
psgrep() {
    # last arg is pgrep pattern, rest are args for ps
    local ps_args
    while test $# -gt 1; do
        ps_args="$ps_args $1"
        shift
    done

    local pattern="$1"

    local pids="$(pgrep -d , -f "$pattern")"
    if test -n "$pids"; then
        psc -p "$pids" $ps_args
    else
        error "No processes matching $pattern"
        return 1
    fi
}

# print the absolute path of the directory containing the specified file
realdir() {
    dirname "$(readlink -f "$1")"
}

# show the most recently changed files
# defaults to the showing the last 10, override with -<number>
recent() {
    local lines

    lines=10
    case "$1" in -*)
        lines=${1#-}
        shift
        ;;
    esac
    ls -t -1 "$@" | head -n $lines
}

# keep trying a command until it works
# (e.g. retry ping -c 1 host)
retry() {
    while true; do
        if "$@"; then
            bell
            break
        else
            sleep 10
        fi
    done
}

# remove the ssh known host from the specified line number
rmkey() {
    delline "$1" "$HOME/.ssh/known_hosts"
}

# run a command with the first argument moved to the end
# e.g. first_arg_last grep ~/.history <args> runs grep <args> ~/.history
first_arg_last() {
    local command
    local arg
    command=$1
    arg=$2
    shift 2
    "$command" "$@" "$arg"
}

# convert a time from one timezone to another
# tz2tz <from timezone> <to timezone> <date spec>
tz2tz() {
    local from="$1"
    local to="$2"
    shift 2
    TZ="$to" date -d 'TZ="'"$from"'"'" $*"
}

# convert from Unix timestamp in micros to a human-readable datetime string
udate() {
    date -d @$(($1 / 1000000)) "$@"
}

# convert from UTC to local time
utc2() {
    date -d 'TZ="UTC" '"$1"
}

# hook to run the given command under a custom ssh-agent
with_agent() {
    "$@"
}

# print the definition of the given command, alias, or function
what() {
    if is_zsh; then
        whence -f "$1"
    elif is_bash; then
        case "$(type -t "$1")" in function)
            typeset -f "$1";;
        *)
            command -v "$1";;
        esac
    else
        type "$1"
    fi
}

# run a command under set -x
wx() {
    set -x
    "$@"
    set +x
}

alias jc='journalctl --no-hostname'
alias sc='systemctl'
alias uc='systemctl --user'

##################################
# ENVIRONMENT SETUP FOR ALL SHELLS
# Set $PATH early in case other stuff here needs it.

CDPATH=".:$HOME:$HOME/conf:$HOME/conf/config"
GOPATH="$HOME"
export GOPATH

add_path "$HOME/android-sdk-linux/platform-tools"
add_path "$HOME/Android/Sdk/platform-tools"
add_path "$HOME/depot_tools"
add_path "$HOME/google-cloud-sdk/bin"
add_path "$HOME/.cargo/bin"
add_path "$HOME/.local/bin"
add_path "$HOME/bin" start
add_path "$GOPATH/bin" start
add_path "$HOME/scripts" start
# scripts.home, scripts.work, etc. override scripts
for dir in "$HOME"/scripts.*; do
    add_path "$dir" start
done
for dir in /opt/*/bin; do
    add_path "$dir" end
done
add_path /sbin end
add_path /usr/sbin end

# set HISTORY_FILE for log_history
HISTORY_FILE=$HOME/.history

export LESS="-R"
if test -f "$HOME/scripts/lessopen"; then
    export LESSOPEN="|$HOME"'/scripts/lessopen "%s"'
fi

test -r "$HOME"/.inputrc && export INPUTRC="$HOME"/.inputrc

# default programs
# kitty wants EDITOR to be set even for non-interactive shells
is_runnable vi && export EDITOR=vi
is_runnable vim && export EDITOR=vim
is_runnable editline && export EDITOR=editline
is_runnable more && export PAGER=more
is_runnable less && export PAGER=less
is_runnable meld && test -n "$DISPLAY" && export DIFF=meld

# program defaults
export BLOCKSIZE=1024
export CLICOLOR=true
export GREP_COLOR=4   # BSD grep and older GNU grep - underline matches
export GREP_COLORS='mt=4'  # GNU grep - underline matches

# colors for ls
case "$TERM" in linux|putty|vt220)
    # colors for white on black
    export LSCOLORS='ExFxxxxxCxxxxx'
    export LS_COLORS='no=00:fi=00:di=01;34:ln=01;35:so=00;00:bd=00;00:cd=00;00:or=01;31:pi=00;00:ex=01;32'
    ;;
*)
    # colors for black on white
    export LSCOLORS='exfxxxxxcxxxxx'
    export LS_COLORS='no=00:fi=00:di=00;34:ln=00;35:so=00;00:bd=00;00:cd=00;00:or=00;31:pi=00;00:ex=00;32'
    ;;
esac

#########################
# INTERACTIVE SHELL SETUP
# Set up the prompt, title, key bindings, etc.

if is_interactive; then

    log_history "New session as $USERNAME: $0 $*"

    # regain use of Ctrl+S and Ctrl+Q
    stty start undef stop undef

    # determine the graphics mode escape sequences
    color=false
    if is_runnable tput; then
        if quiet tput longname; then
            bold="$(tput bold)"
            underline="$(tput smul)"
            standout="$(tput smso)"
            normal="$(tput sgr0)"
            black="$(tput setaf 0)"
            red="$(tput setaf 1)"
            green="$(tput setaf 2)"
            yellow="$(tput setaf 3)"
            blue="$(tput setaf 4)"
            magenta="$(tput setaf 5)"
            cyan="$(tput setaf 6)"
            white="$(tput setaf 7)"
            color=true

            khome="$(tput khome)"
            kend="$(tput kend)"
            kdch1="$(tput kdch1)"
        fi
    fi

    # determine the window title escape sequences
    case "$TERM" in
    aixterm|dtterm|putty|rxvt|xterm*)
        titlestart=']0;'
        titlefinish=''
        ;;
    cygwin)
        titlestart='];'
        titlefinish=''
        ;;
    konsole)
        titlestart=']30;'
        titlefinish=''
        ;;
    screen*)
        # window title
        # screen/tmux are responsible for setting the terminal title
        titlestart='k'
        titlefinish='\'
        ;;
    *)
        if is_runnable tput; then
            if quiet tput longname; then
                titlestart="$(tput tsl)"
                titlefinish="$(tput fsl)"
            fi
        else
            titlestart=''
            titlefinish=''
        fi
        ;;
    esac

    # prevent running "exit" if the user is still running jobs in the background
    # the user is expected to close the jobs or disown them
    _exit()
    {
        case $- in *m*)
            # this way works in bash and zsh
            jobs | wc -l | grep -q '^ *0 *$'
            if test $? -eq 0; then
                    command exit "$@"
            else
                jobs
            fi
                    ;;
        *)
            command exit "$@"
            ;;
        esac
    }

    path_or_empty() {
        local pathname
        pathname=$(command -v $1)
        if test -e "$pathname"; then
            echo "$pathname"
        else
            echo
        fi
    }

    #alias '?'='path_or_empty'
    alias @='path_or_empty'
    alias bindkeys='daemon xbindkeys'
    code_patterns="{*.c,*.h,*.cc,*.coffee,*.go,*.java,*.js,*.pl,*.py,*.sh,*.rb,*.swig,*.ts}"
    code_includes="$(eval echo --include=$code_patterns)"
    alias c='less -FX'
    alias cdf='cdfile'
    alias cg='rg '"$code_includes"
    alias ct='ctags -R'
    alias cx='chmod +x'
    alias d='mycode'
    mycode() {
        makesettings
        code .
    }
    codedir() {
        makemakefile
        maketsconfig
        maketasks
        makelocal
        m&
        sleep 5
        code --add .
        local _dir
        for _dir in "$(gendir)"; do
            test -d "$_dir" || continue
            code --add "$_dir"
        done
    }
    makelocal() {
        :
    }
    daemon() {
        pkill "$1"
        (setsid "$1"&)
    }
    alias diga='dig +noall +answer +search'
    alias digs='dig +short +search'
    download() { cd "$HOME/Downloads"; wget "$@"; }
    # function rather than an alias so it looks better in the xterm title.
    e() { "${EDITOR:-vim}" "$@"; }
    alias eg='g -E'
    alias emacs='emacs -nw'
    alias f='command fg'
    alias g='grep -In'
    alias gdb='gdb -q '
    # Note that grep options must go after ~/.history.
    gh() { first_arg_last grep ~/.history -a "$@"; }
    alias gitdir='git rev-parse --git-dir'
    alias gl='cd /var/log'
    alias h='head'
    alias headers='curl -L -i -sS -o/dev/null -D-'
    if have_command chg; then
        alias hg='chg'
    fi
    alias hms='date +"%H:%M:%S"'
    alias hmsns='date +"%H:%M:%S.%N"'
    alias hosts='getent hosts'
    alias ipy='ipython'
    alias ipy3='ipython3'
    alias killcode='pkill -f /usr/share/code/code'
    alias kssh='ssh -o PreferredAuthentications=publickey'
    if have_command l; then
        alias l='l -Kv -e -x'
        alias ll='l -pTBV -h --time-style=relative'
        alias lt='l -Tt'
    elif quiet ls --color=auto -v -d /; then
        alias l='ls --color=auto -v -b -x'
        alias ll='l -l'
        alias lt='ll -t'
    else
        alias l='ls -v -b -x'
        alias ll='l -l'
        alias lt='ll -t'
    fi
    alias l1='l -1'
    alias la='l -a'
    alias latest='recent -1'
    alias lc='l -C'
    lssock() {
        lsof -a -n -P -i "$@"
    }
    alias lss='lssock'
    alias j='jobs'
    m() { make -f .Makefile "$@"; }
    ml() { m lint; }
    # shadows magtape command, but who uses that?
    mt() { m test; }
    alias n='date +"%Y%m%d%H%M%S"'
    alias now='date +"%Y-%m-%dT%H:%M:%S"'
    alias nowns='date +"%Y-%m-%dT%H:%M:%S.%N"'
    alias nv='nvim'
    # function rather than an alias so it looks better in the xterm title.
    p() { "${PAGER:-more}" "$@"; }
    alias pgrep,='pgrep -d , -f'
    alias pg,='pgrep'
    alias phup='pkill -HUP'
    alias popd='popd >/dev/null'
    alias psg='psgrep'
    alias psu='ps -o user,pid,start,time,pcpu,stat,cmd'
    alias pushd='pushd >/dev/null'
    alias pd='pushd'
    alias po='popd'
    alias pssh='ssh -o PreferredAuthentications=keyboard-interactive,password'
    alias pr='projectroot'
    alias py='python'
    alias py2='python2'
    alias py3='python3'
    alias r='fc -e - --'
    alias rerc="source '$HOME/.shrc'"
    alias rg='g -IR --exclude-dir=".*"'
    rh() { gh "$@" | tail -n 20; }
    alias q='xa'
    alias s='subl'
    alias spell='aspell -a'
    alias sr='ssh -l root'
    alias symlink='ln -sr'
    alias t='tail'
    alias tf='t -f'
    alias tl='t -f /var/log/syslog'
    alias today='date +"%Y-%m-%d"'
    alias userctl='systemctl --user'
    alias userjournal='journalctl --user'
    alias userjnl='userjournal'
    view() { vim -R -c ":set mouse=" "$@"; }
    alias v='view'
    alias vl='view /var/log/syslog'
    alias wcp='with_agent scp'
    alias wsh='with_agent ssh'
    alias x='xa'
    xa() { while command fg; do :; done; _exit; }
    alias xevkey='xev -event keyboard'
    alias xr='DISPLAY=:0.0 xrandr'

    set_up_ssh_aliases() {
        local _ssh_machines="$HOME/.ssh/machines"
        test -f "$_ssh_machines" || return

        while IFS=$'\n' read -r _fqdn; do
            local _short="${_fqdn%%.*}"
            eval "$_short=$_fqdn"
            eval "$_short"'() { ssh "$@" '"$_fqdn"'; }'
        done <"$_ssh_machines"
    }
    set_up_ssh_aliases

    # expand aliases after nohup, etc.
    for wrapper in nohup strace sudo; do
        alias $wrapper="$wrapper "
    done

    # in case root isn't available, fall back to sudo
    have_command root && alias root='root ' || alias root='sudo '

    # enable colors in commands that support it
    # (ls is done above)
    quiet grep -q --color=auto "" /etc/hosts && alias grep='grep --color=auto'

    alias ginfo=$(path info)
    # aliases to abstract away differences between package managers
    if have_command yum; then
        alias yum='root yum --cacheonly'
        alias update='root yum makecache'
        alias search='yum search'
        alias show='yum info'
        alias install='root yum install'
        alias installed='rpm -qa'
        alias uninstall='root yum erase'
        alias reinstall='root yum reinstall'
        alias autoremove='root yum autoremove'
        alias upgrade='root yum upgrade'
        alias versions='yum list'
        alias files='repoquery --file'
    elif have_command apt-get; then
        alias update='root apt-get update'
        alias search='apt-cache search --names-only'
        alias show='apt-cache show'
        alias install='root apt-get install'
        alias installed="dpkg-query --show --showformat='\${binary:Package;-36} \${Version;-32} \${Status;-10}\n'"
        alias uninstall='root apt-get remove'
        alias reinstall='root apt-get install --reinstall'
        alias autoremove='root apt-get autoremove'
        alias upgrade='root apt-get upgrade'
        alias versions='apt-cache policy'
        alias files='apt-file search'
    else
        error "No supported package manager found"
    fi

    # make +<num> change directories and %<num> resume jobs
    # this matches the first column in the prompt output
    case "$shell" in
    bash|zsh)
        # use legacy function syntax then alias to prevent dash syntax errors,
        # which could cause X session errors on Debian/Ubuntu
        plus() {
            pushd "$@" >/dev/null
        }
        minus() {
            popd "$@" >/dev/null
        }
        plusminus() {
            pushd "$OLDPWD" >/dev/null
        }
        pushpop() {
            eval "pushd ~$1" >/dev/null
            popd +$(($1 + 1)) >/dev/null
        }
        alias -- +='plus'
        alias -- -='minus'
        alias -- +-='plusminus'
        for i in $(seq 0 9); do
            alias -- +$i='pushpop '$i
        done

        quiet alias '$'=' ' || true
        ;;
    *)
        # ksh and dash lack %, %1, etc.
        alias %='fg'
        for i in $(seq 0 9); do
            alias %$i='fg %'$i
        done
        ;;
    esac

    # set a basic prompt that doesn't rely on precommand and preprompt hooks
    basic_prompt() {
        PS1='$ '
        PS2='_ '
        PS3='#? '
        set_title "$(title)"
    }

    # commands to execute before the prompt is displayed
    preprompt() {
        last_job_info
        current_command=
        SECONDS=0
        set_color 'normal'
        printf '\n'
        bar $((COLUMNS))
        printf '\r%s %s%s \n' "$(host_info)" "$(dir_info)" "$(maybe_space "$(auth_info)")"
        job_info
        set_title "$(title)"
        set_prompt
        flash_terminal
    }

    maybe_space() {
        test -n "$*" && printf ' %s' "$*"
    }

    bar() (
        i=0
        while test $i -lt $1; do
            printf '‚Äï'
            i=$((i+1))
        done
    )

    last_job_info() {
        # Must be the very first thing.
        local last_error="$(${shell}_last_error)"

        test -z "$current_command" && return

        set_color 'normal'
        local printed=false
        if test -n "$last_error"; then
            red "$last_error"
            printed=true
        fi
        local duration=
        if test "$SECONDS" -gt 0; then
            local hours minutes seconds
            seconds="$SECONDS"
            hours=$(($seconds/3600))
            seconds=$(($seconds-$hours*3600))
            minutes=$(($seconds/60))
            seconds=$(($seconds-$minutes*60))
            if test "$hours" -gt 0; then
                duration="$hours hours $minutes minutes $seconds seconds"
            elif test "$minutes" -gt 0; then
                duration="$minutes minutes $seconds seconds"
            elif test "$seconds" -gt 1; then
                duration="$seconds seconds"
            fi
        fi
        if test -n "$duration"; then
            if $printed; then
                printf ' '
            fi
            yellow "took $duration"
            printed=true
        fi
        if $printed; then
            printf '\n'
        fi
    }

    # get the user's attention
    flash_terminal() {
        case $TERM in xterm|xterm-*)
            bell
            ;;
        esac
    }

    # return true if the current user is root
    i_am_root() {
        test $UID -eq 0
    }

    # return true if this machine is my laptop
    _on_my_laptop() {
        if test -f "$HOME"/.laptop; then
            true
        else
            case "$HOSTNAME" in
            *laptop*) true;;
            *)        false;;
            esac
        fi
    }

    # return true if this machine is my laptop
    on_my_laptop() {
        if test -z "${LAPTOP:-}"; then
            if _on_my_laptop; then
                LAPTOP=true
            else
                LAPTOP=false
            fi
        fi
        "$LAPTOP"
    }

    # return true if this is a non-production machine I use to get work done
    on_my_machine() {
        on_my_workstation || on_my_laptop
    }

    # return true if it's already obvious which host I'm on
    show_hostname_in_title() {
        ! inside_tmux
    }

    connected_via_ssh() {
        test -n "${SSH_CONNECTION:-}"
    }

    # return true if this session is on a remote machine
    connected_remotely() {
        connected_via_ssh
    }

    # return true if this session is attached to shpool
    in_shpool_session() {
        test -n "$SHPOOL_SESSION_NAME"
    }

    inside_tmux() {
        test -n "$TMUX"
    }

    # return true if this machine is a production machine
    on_production_host() {
        ! on_my_machine && ! on_test_host && ! on_dev_host
    }

    # return true if this machine is a test (i.e. non production) machine
    on_test_host() {
        case "$HOSTNAME" in
            *test*) true;;
            *)      false;;
        esac
    }

    on_dev_host() {
        case "$HOSTNAME" in
            *dev*) true;;
            *)     false;;
        esac
    }

    # print information about this machine
    host_info() {
        if on_production_host; then
            set_color 'red'
        fi

        printf '%s' "$(short_hostname)"
        set_color 'normal'
        printf '\n'
    }

    # print information about all shell jobs
    # intended to be used in the preprompt
    job_info() {
            jobs |
                sed -e 's/^\[\([0-9][0-9]*\)\][-+ ]*[^ ]* */%\1 /' |
                grep -v '(pwd now:'
    }

    status_chars() {
        :
    }

    # print directory stack listing in "+<number> <directory>" format
    # intended to be used in the preprompt
    dir_info() {
            blue "$(_dir_info "$PWD")"
    }
    _dir_info() {
        # if the directory is under version control, print
        # <project name> <subdir under project root> <branch> <status>,
        # otherwise just the directory with $HOME turned into ~
        cd "$1"
        local projectroot="$(projectroot)"
        if test -n "$projectroot"; then
            green "$(basename "$projectroot")"
            local projectsubdir
            projectsubdir="$(trim_prefix "$projectroot" "$PWD")"
            if test -n "$projectsubdir"; then
                printf ' '
                blue "$projectsubdir"
            fi
            local branch="$(vcs branch)"
            if test -n "$branch"; then
                printf ' %s' "$branch"
            fi
            local statuschars="$(status_chars)"
            if test -n "$statuschars"; then
                printf ' '
                yellow "$statuschars"
            fi
            # local branch
            # branch="$(branch)"
            # if test -n "$branch"; then
            #     printf ' '
            #     green "$branch"
            # fi
        else
            tilde_directory
        fi
    }

    short_pwd() {
        local projectname="$(projectname)"
        if test -n "$projectname"; then
            printf '%s' "$projectname"
        else
            printf '%s' "$(basename "$PWD")"
        fi
    }

    project_or_command_or_pwd() {
        local projectname="$(projectname)"
        if test -n "$projectname"; then
            printf '%s' "$projectname"
        elif test -n "${current_command:-}"; then
            printf '%s' "${current_command%% *}"
        else
            printf '%s' "$(basename "$PWD")"
        fi
    }

    project_or_pwd() {
        local projectname="$(projectname)"
        if test -n "$projectname"; then
            printf '%s' "$projectname"
        else
            printf '%s' "$(basename "$PWD")"
        fi
    }

    # print the name of the current branch
    branch() {
        :
    }

    # print the name of all branches
    branches() {
        :
    }

    blue() {
        if $color; then
            printf '%s%s%s' "$blue" "$*" "$normal"
        else
            printf '%s' "$*"
        fi
    }
    green() {
        if $color; then
            printf '%s%s%s' "$green" "$*" "$normal"
        else
            printf '%s' "$*"
        fi
    }
    # shadows /bin/red, but I don't use it here
    red() {
        if $color; then
            printf '%s%s%s' "$red" "$*" "$normal"
        else
            printf '%s' "$*"
        fi
    }
    yellow() {
        if $color; then
            printf '%s%s%s' "$yellow" "$*" "$normal"
        else
            printf '%s' "$*"
        fi
    }

    # print what remote commits would get pulled
    incoming() {
        :
    }

    # print what local commits would get pushed
    outgoing() {
        :
    }

    trim_prefix() {
        expr substr "$2" $(expr length "$1" + 2) 9999
    }

    # load all the version control functions (git_*, hg_*, etc.)
    if test -f "$HOME/.shrc.vcs"; then
        source "$HOME/.shrc.vcs"
    fi

    # print a message describing the last error, or empty if no error
    bash_last_error() {
        laststatus=$?
        case $laststatus in
        0)   ;;
        130) echo "interrupted";;
        148) ;;  # suspended
        *)   echo "status $laststatus";;
        esac
    }

    # print a message describing the last error, or empty if no error
    sh_last_error() {
        laststatus=$?
        case $laststatus in
        0)   ;;
        *)   echo "status $laststatus";;
        esac
    }
    alias ksh_last_error=sh_last_error

    # print a message describing the last error, or empty if no error
    zsh_last_error() {
        laststatus=$?
        case $laststatus in
        0)   ;;
        20)  ;;  # suspended (zsh < 5.0.7)
        130) echo "interrupted";;
        148) ;;  # suspended (zsh >= 5.0.7)
        *)   echo "status $laststatus";;
        esac
    }

    # get a short version of the hostname for use in the prompt or window title
    short_hostname() {
        local hostname
        local site
        hostname="${HOSTNAME%%.*}"
        hostname="${hostname#$USERNAME-}"
        printf '%s' "$hostname"
    }

    # ssh to remote host using current shell's config
    mssh() {
        case $SHELL in
        *bash) bssh $ssh_opts "$@";;
        *zsh)  zssh $ssh_opts "$@";;
        *)     ssh  $ssh_opts "$@";;
        esac
    }

    # ssh to remote host using this host's bashrc
    bssh() {
        # allow passing a single block of options to ssh/scp, e.g. -4
        # TODO: handle more options
        local ssh_opts=
        case "$1" in -*)
            ssh_opts="$1"
            shift
            ;;
        esac
        ssh $ssh_opts -t "$@" '
export BASHRC=$(mktemp /tmp/bash.XXXXXXXX);
scp $ssh_opts '"$HOSTNAME:${BASHRC:-.bashrc}"' "$BASHRC";
exec bash --rcfile "$BASHRC" -i'
    }

    # ssh to remote host using this host's zshrc
    zssh() {
        # allow passing a single block of options to ssh/scp, e.g. -4
        # TODO: handle more options
        local ssh_opts=
        case "$1" in -*)
            ssh_opts="$1"
            shift
            ;;
        esac
        ssh $ssh_opts -t "$@" '
export ZDOTDIR=$(mktemp -d /tmp/zsh.XXXXXXXX);
scp $ssh_opts '"$HOSTNAME:${ZDOTDIR:-$HOME}/.zshrc"' "$ZDOTDIR";
exec zsh -i'
    }

    # print the current directory with $HOME changed to ~
    tilde_directory() {
        printf '%s' "$PWD" | sed -e 's#^'"$HOME"'#~#'
    }

    # print the string that should be used as the xterm title
    title() {
        if show_hostname_in_title; then
            short_hostname
            printf ' '
        fi
        project_or_pwd
    }

    # set all the prompt strings
    # done this way so that \[ (bash) and \{ (zsh) are handled consistently
    set_prompt() {
        PS1="$(ps1)"
    }

    # output the string that should be used as the prompt
    ps1() {
        keymap_character
        ps1_character
        printf ' '
    }

    # print a character that should be the last part of the prompt
    ps1_character() {
        if test $UID -eq 0; then
            printf '#'
        else
            printf '$'
        fi
    }

    # return whether the given shell option is on
    getshopt() {
        set -o | while read opt val; do
            if test "$opt" = "$1"; then
                test "$val" = "on"
                return
            fi
        done
        false
    }

    # print a character indicating whether vi command mode is active
    keymap_character() {
        getshopt vi || return
        case "${keymap:-}" in
        vicmd)
            printf 'NORMAL'
            ;;
        viins|main)
            printf 'INSERT'
            ;;
        esac
    }

    # function to run just before running a command from the command line
    # see also preexec (zsh) and DEBUG (bash)
    # the first argument is the command line being run
    precommand() {
        log_history "$*"
        current_command="$(expand_job "$*")"
        set_title "$(title)"
        set_color 'normal'
        SECONDS=0
    }

    # set the xterm title to the supplied string
    set_title() {
        if test -n "$titlestart"; then
            printf '%s%s%s' "$titlestart" "$*" "$titlefinish"
        fi
    }

    # expand job references such as %1 into the command name
    expand_job() {
        local arg

        test $# -eq 0 && return

        arg=$1
        shift

        case "$arg" in f|fg)
            arg='%+'
            ;;
        esac
        case "$arg" in '%'*)
            # can't use job_info here in bash
            arg="$(jobs "$arg" | sed -e 's/^\[[0-9][0-9]*\][-+ ]*[^ ]* *//')"
            ;;
        esac
        printf '%s' "$arg" "$@"
    }

    # print the supplied string inside prompt escape sequences
    # that tell the shell the escape sequences do not move the cursor
    prompt_color() {
        local color_escape

        color_escape=$(set_color "$*")

        if test -n "$color_escape" && test -n "$escape_start" && test -n "$escape_end"; then
            printf '%s%s%s' "$escape_start" "$normal" "$escape_end"
            printf '%s%s%s' "$escape_start" "$color_escape" "$escape_end"
        fi
    }
    # set the terminal color to the specified color or terminal attribute
    # accepts multiple arguments, e.g. set_color bold blue underline
    set_color() {
        local arg

        for arg; do
            eval "printf \"%s\" \"\$$arg\""
        done
    }
    escape_start=
    escape_end=

    terminal_supports_bracketed_paste() {
        case $TERM in rxvt-unicode|xterm)
            true;;
        *)
            false;;
        esac
    }

    enable_bracketed_paste() {
        if terminal_supports_bracketed_paste; then
            printf '\e[?2004h'
        fi
    }

    disable_bracketed_paste() {
        if terminal_supports_bracketed_paste; then
            printf '\e[?2004l'
        fi
    }

    case "$shell" in
    zsh)
        # zsh enhancements
        setopt AUTO_CD
        setopt CORRECT
        setopt DVORAK
        setopt EXTENDED_GLOB
        setopt PROMPT_PERCENT
        setopt PUSHD_SILENT

        # complete both commands and files for the first word, to support autocd
        compctl -C -cf
        # fall back to case-insensitive completion then fuzzy completion
        zstyle ':completion:*' matcher-list '' \
            'm:{a-z\-}={A-Z\_}' \
            'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
            'r:|?=** m:{a-z\-}={A-Z\_}'

        # load auto completions
        autoload -Uz compinit
        compinit

        # user input appears in bold
        declare -a zle_highlight
        zle_highlight[0]="default:bold"

        escape_start='%{'
        escape_end='%}'

        # install preprompt and precommand functions
        enable_prompt_hooks() {
            precmd() {
                preprompt
            }
            preexec() {
                precommand "$1"
            }
        }
        disable_prompt_hooks() {
            unset -f precmd
            unset -f preexec
            basic_prompt
        }
        enable_prompt_hooks

        # use underscores in the function names so dash doesn't choke
        zle_keymap() {
            emulate -L zsh
            keymap=$KEYMAP
            set_prompt
            zle reset-prompt
            zle -R
        }
        zle_line_init() {
            zle_keymap
            enable_bracketed_paste
        }
        zle_keymap_select() {
            zle_keymap
        }
        zle_line_finish() {
            zle_keymap
            disable_bracketed_paste
        }
        zle -N zle-line-init zle_line_init
        zle -N zle-keymap-select zle_keymap_select
        zle -N zle-line-finish zle_line_finish

        # make Home, End, and Delete keys work
        _terminfo_bind() {
            if test -n "${terminfo[$1]:-}"; then
                bindkey -M emacs "${terminfo[$1]}" "$2"
                bindkey -M viins "${terminfo[$1]}" "$2"
                bindkey -M vicmd "${terminfo[$1]}" "$2"
            fi
        }
        _terminfo_bind kdch1 delete-char
        _terminfo_bind kDC5 delete-word
        _terminfo_bind cub1 backward-delete-word
        _terminfo_bind khome beginning-of-line
        _terminfo_bind kend end-of-line

        # prevent PageUp and PageDown from inserting a bogus ~
        zle_noop() { :; }
        zle -N zle-noop zle_noop
        _terminfo_bind knp zle-noop
        _terminfo_bind kpp zle-noop

        # ignore history from other sessions when using Up/Down arrow keys
        up_line_or_local_history() {
            zle set-local-history 1
            zle up-line-or-history
            zle set-local-history 0
        }
        zle -N up-line-or-local-history up_line_or_local_history
        down_line_or_local_history() {
            zle set-local-history 1
            zle down-line-or-history
            zle set-local-history 0
        }
        zle -N down-line-or-local-history down_line_or_local_history
        _terminfo_bind cuu1 up-line-or-local-history
        _terminfo_bind kcuu1 up-line-or-local-history
        _terminfo_bind cud1 down-line-or-local-history
        _terminfo_bind kcud1 down-line-or-local-history

        # make Shift+Tab do menu complete backwards
        _terminfo_bind cbt reverse-menu-complete

        # add bindings for both blank and non-alpha word motion
        bindkey -M emacs '\eb' vi-backward-blank-word
        bindkey -M emacs '\eB' vi-backward-word
        bindkey -M emacs '\ef' vi-forward-blank-word
        bindkey -M emacs '\eF' vi-forward-word

        vi_cmd_mode_onemore() {
            OLDCURSOR=$CURSOR
            zle vi-cmd-mode
            CURSOR=$OLDCURSOR
        }
        VIONEMORE=1
        zle -N vi-cmd-mode-onemore vi_cmd_mode_onemore
        bindkey -M viins '\e' vi-cmd-mode-onemore

        # make "cw" act like "cw" rather than "ce"
        bindkey -a -s cw dwi

        # add Emacs bindings to Vi editing mode
        _bind_vi() {
            bindkey -M viins "$@"
            bindkey -M vicmd "$@"
        }
        # bind Esc+<letter> in insert mode and <letter> in command mode
        _bind_vi_esc() {
            bindkey -M viins '\e'"$@"
            bindkey -M vicmd "$@"
        }
        _bind_vi '^a' beginning-of-line
        _bind_vi '^e' end-of-line
        _bind_vi '^k' kill-line
        _bind_vi '^n' down-line-or-local-history
        _bind_vi '^p' up-line-or-local-history
        _bind_vi '^r' history-incremental-search-backward
        _bind_vi '^s' history-incremental-search-forward
        _bind_vi '^u' kill-whole-line
        _bind_vi '^w' backward-kill-word
        _bind_vi '^y' yank
        _bind_vi_esc 'b' vi-backward-blank-word
        _bind_vi_esc 'B' vi-backward-word
        _bind_vi_esc 'f' vi-forward-blank-word
        _bind_vi_esc 'F' vi-forward-word
        _bind_vi_esc 'y' yank-pop
        _bind_vi_esc '_' insert-last-word
        _bind_vi '\e^?' backward-kill-word

        zsh_sed_command() {
            emulate -LR zsh
            local SEDARG=
            zle -R ":$SEDARG"
            local key
            while read -k key; do
                case "$key" in
                $'\e')
                    # Escape
                    return
                    ;;
                $'\n'|$'\r')
                    # Enter or Return
                    BUFFER="$(echo "$BUFFER" | sed -r -e "$SEDARG")"
                    return
                    ;;
                $'\b'|$'\x7F')
                    # Backspace or Delete
                    SEDARG="${SEDARG[1,-2]}"
                    ;;
                *)
                    SEDARG="$SEDARG$key"
                    ;;
                esac
                zle -R ":$SEDARG"
            done
            return 1
        }
        zle -N zsh-sed-command zsh_sed_command
        bindkey -M vicmd : zsh-sed-command

        # try to differentiate between Esc vi command and Alt+something
        KEYTIMEOUT=1

        # enable support for xterm bracketed paste

        # switch to the paste keymap
        start_paste() {
            bindkey -A main previous
            bindkey -A paste main
        }
        # strip a single final newline and switch back to the previous keymap
        end_paste() {
            LBUFFER="${LBUFFER%
}"
            bindkey -A previous main
        }
        # associate the bindkey widgets with the corresponding functions
        zle -N start-paste start_paste
        zle -N end-paste end_paste
        # .safe is self-insert except for ^J and ^M
        bindkey -N paste .safe
        # make newlines not act like Enter
        # (have it insert a newline, not do accept-line)
        bindkey -M paste '^J' self-insert
        # make pasted newlines appear as newlines
        # (terminal sends ^M but zsh wants ^J)
        bindkey -M paste -s '^M' '^J'
        # start pasting when seeing the start escape sequence
        bindkey -M emacs '^[[200~' start-paste
        bindkey -M viins '^[[200~' start-paste
        bindkey -M vicmd '^[[200~' start-paste
        # end pasting when seeing the finish escape sequence
        bindkey -M paste '^[[201~' end-paste
        # translate some hard-to-spot Unicode characters to ASCII
        bindkey -M paste -s '‚Äú' '"'
        bindkey -M paste -s '‚Äù' '"'
        bindkey -M paste -s '‚Ä¶' '...'
        bindkey -M paste -s '¬†' ' '

        ;;
    bash)
        # bash enhancements
        shopt -s autocd
        shopt -s checkwinsize
        shopt -s lithist

        escape_start='\['
        escape_end='\]'

        # install preprompt and precommand functions
        # the DEBUG trap is disabled during running of preprompt to avoid lots
        # of extra processing and several pointless title changes
        install_precommand_trap() {
            trap 'precommand "$BASH_COMMAND"; remove_precommand_trap' DEBUG
            set_title "$(title)"
        }
        remove_precommand_trap() {
            trap - DEBUG
        }
        enable_prompt_hooks() {
            PROMPT_COMMAND='preprompt; install_precommand_trap'
        }
        disable_prompt_hooks() {
            remove_precommand_trap
            PROMPT_COMMAND=
            basic_prompt
        }
        enable_prompt_hooks

        # these key bindings should be kept in sync with ~/.inputrc
        # they are duplicated here so scp ~/.shrc newhost: is sufficient

        _bind_vi() {
            bind -m vi-command "$@"
            bind -m vi-insert "$@"
        }

        _bind_emacs() {
            bind -m emacs "$@"
        }

        _bind_all() {
            _bind_emacs "$@"
            _bind_vi "$@"
        }

        # make motion commands treat all non-space characters as word chars
        _bind_emacs '"\eb": vi-bWord'
        _bind_emacs '"\ef": vi-fWord'
        _bind_emacs '"\ed": shell-kill-word'
        _bind_emacs '"\eD": shell-kill-word'
        _bind_emacs '"\e\C-?": unix-word-rubout'
        _bind_emacs '"\e[3;5~": kill-word'
        _bind_emacs '"\C-h": backward-kill-word'

        # add motion commands that treat alpha<->non-alpha as the word boundary
        _bind_emacs '"\eB": vi-bword'
        _bind_emacs '"\eF": vi-fword'

        # prevent Page Up and Page Down from inserting a bogus ~
        # TODO: use terminfo
        # TODO: double check tty-status is a sane thing
        _bind_all '"\e[5~": tty-status'
        _bind_all '"\e[6~": tty-status'

        # standardize Ctrl+U behavior
        _bind_all '"\C-u": kill-whole-line'

        # add Emacs bindings to Vi editing mode
        _bind_vi '"\C-a": beginning-of-line'
        _bind_vi '"\C-e": end-of-line'
        _bind_vi '"\C-k": kill-line'
        _bind_vi '"\C-n": next-history'
        _bind_vi '"\C-p": previous-history'
        _bind_vi '"\C-r": reverse-search-history'
        _bind_vi '"\C-s": forward-search-history'
        _bind_vi '"\C-w": backward-kill-word'
        _bind_vi '"\C-y": yank'
        _bind_vi '"\C-_": insert-last-argument'
        _bind_vi '"\eb": vi-bWord'
        _bind_vi '"\eB": vi-bword'
        _bind_vi '"\ef": vi-fWord'
        _bind_vi '"\eF": vi-fword'
        _bind_vi '"\ey": yank-pop'
        _bind_vi '"\e\C-?": unix-word-rubout'

        # Make Esc toggle between command and insert mode
        bind -m vi-command '"\e": vi-insertion-mode'
    esac

    # set up per-package tab completion
    case "$shell" in bash|zsh)
        # define "have", used by some scripts in /etc/bash_complete.d/*
        have() {
            unset have
            if type "$1" >/dev/null 2>&1; then
                have=yes
                true
            else
                false
            fi
        }

        # /etc/bash_completion doesn't work in zsh, but most of the scripts
        # under /etc/bash_completion.d do.  silence the output to ignore the
        # ones that don't.
        for f in /etc/bash_completion.d/*; do
            source "$f" >/dev/null 2>&1
        done
        ;;
    esac

    # set a simple prompt for non-bash non-zsh
    # (will be overridden immediately by bash and zsh)
    basic_prompt
    alias _=' '

    # command line editing
    set -o emacs
fi

# source local overrides file (work vs home, etc.)
test -f "${ZDOTDIR:-$HOME}/.shrc.local" && . "${ZDOTDIR:-$HOME}/.shrc.local"

if is_interactive && connected_remotely && ! in_shpool_session; then
    if confirm "Start shpool"; then
        autoshpool
    fi
    if need_auth; then
        if confirm "Auth"; then
            auth
        fi
    fi
fi

# finish with a zero exit status so the first prompt is '$' rather than '?'
true

# Use tabs for indentation so we can edit this in nvi if necessary.
# vi: set sw=4 ts=33:
