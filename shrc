# $Id$
#
# POSIX shell startup commands
#
# This script contains functions and settings that are common for all
# POSIX-compatible shells including bash and ksh.

### HELPER FUNCTIONS
# add a directory to the path
addpath()
{
    typeset dir
    typeset pos
    typeset var
    typeset sep
    dir=$1
    pos=$2
    var=${3:-"PATH"}
    sep=${4:-":"}
    OIFS="$IFS"
    IFS="$sep"

    case "$pos" in
    start)
        delpath "$dir" "$var" "$sep"
        eval $var="\$dir""\${$var:+\$sep}""\$$var"
        ;;
    end)
        delpath "$dir" "$var" "$sep"
        eval $var="\$$var""\${$var:+\$sep}""\$dir"
        ;;
    *)
        typeset dirs
        typeset seen
        eval dirs=\$$var
        for d in $dirs
        do
            # directory is already in PATH, leave as is
            test "${dir:-.}" = "${d:-.}" && seen=true
        done
        test -z "$seen" && eval $var="\$$var""\${$var:+$sep}""\$dir"
        ;;
    esac
    IFS="$OIFS"
}

# remove a directory from the path
delpath()
{
    typeset dir
    typeset var
    typeset sep
    dir=$1
    var=${2:-"PATH"}
    sep=${3:-":"}
    NIFS="$IFS"
    IFS="$sep"

    typeset path
    typeset dirs

    eval dirs=\$$var
    for d in $dirs
    do
        test "${d:-.}" = "${dir:-.}" && continue
        path="$path""${path:+$sep}""$d"
    done
    eval $var="\$path"
    IFS="$NIFS"
}

# return true if the command can be found, false otherwise
exists()
{
    typeset cmd
    cmd="$1"

    if type "$cmd" >/dev/null 2>&1
    then
        return 0
    else
        return 1
    fi
}

# run a simple command quietly
quiet()
{
    "$@" >/dev/null 2>&1
    return $?
}

# set the xterm title
settitle()
{
    test -z "${titlestart}" && return 0

    printf "${titlestart}$*${titlefinish}"
}

terminit()
{
    # determine the graphics mode escape sequences
    if exists tput
    then
        bold="$(tput bold)"
        underline="$(tput smul)"
        normal="$(tput sgr0)"
        black="$(tput setaf 0)"
        red="$(tput setaf 1)"
        green="$(tput setaf 2)"
        yellow="$(tput setaf 3)"
        blue="$(tput setaf 4)"
        magenta="$(tput setaf 5)"
        cyan="$(tput setaf 6)"
        white="$(tput setaf 7)"
    fi

    # determine the window title escape sequences
    case "$TERM" in
    aixterm|dtterm|putty|rxvt|xterm*)
        titlestart=']0;'
        titlefinish=''
        ;;
    cygwin)
        titlestart='];'
        titlefinish=''
        ;;
    screen*)
        # status line
        titlestart='_'
        # window title
        #titlestart='k'
        titlefinish='\'
        ;;
    *)
        if exists tput
        then
            titlestart=`tput tsl`
            titlefinish=`tput fsl`
        else
            titlestart=''
            titlefinish=''
        fi
        ;;
    esac
}

### SHELL ENVIRONMENT
#
typeset dir
# set directories to search for commands
# add preferred locations at start
for dir in /opt/*/bin /usr/X11R6/bin /usr/kerberos/bin /usr/posix/bin /usr/gnu/bin /usr/local/bin "$HOME"/bin
do
    test -d "$dir" && addpath "$dir" start
done
# add standard locations if they're not there
for dir in /usr/bin/X11 /usr/bin /bin /usr/sbin /sbin
do
    test -d "$dir" && addpath "$dir"
done
# add the current directory to the end
for dir in .
do
    test -d "$dir" && addpath "$dir" end
done
export PATH

# set directories to search for documentation
for dir in /opt/*/info /usr/local/share/info /usr/local/info "$HOME"/info
do
    test -d "$dir" && addpath "$dir" start INFOPATH
done
for dir in /usr/share/info /usr/info
do
    test -d "$dir" && addpath "$dir" end INFOPATH
done
export INFOPATH
for dir in /opt/*/man /usr/X11R6/man /usr/kerberos/man /usr/posix/man /usr/gnu/man /usr/local/share/man /usr/local/man "$HOME"/man
do
    test -d "$dir" && addpath "$dir" start MANPATH
done
for dir in /usr/share/man /usr/man
do
    test -d "$dir" && addpath "$dir" end MANPATH
done
export MANPATH

# set shell options and environment
CDPATH=":~"
HISTFILE=
HISTSIZE=128
HISTIGNORE="bg:fg: *"
HOST=`hostname`
if exists tty
then
    TTY=`tty`
else
    TTY='?'
fi
if test -z "$UID"
then
    UID=`id -u`
fi
USER=`id -un`

### ALIASES AND FUNCTIONS
# create aliases for commonly invoked commands
if quiet alias
then
    alias apt='aptitude'
    alias bell='echo "\a"'
    alias cx='chmod +x'
    alias g='egrep'
    alias h='history'
    alias hup='kill -HUP'
    alias l='ls'
    alias l.='l -d .*'
    alias la='l -A'
    alias ll='l -l'
    alias lt='l -lt'
    alias j='jobs'
    alias nohup='nohup '
    alias pd='pushd'
    alias po='popd'
    alias psme='ps -f -U "${USER:-${LOGNAME}}"'
    alias rcslog='rlog'
    alias rdiff='rcsdiff'
    alias sudo='sudo '  # expand aliases after sudo

    # set default flags
    if quiet grep --color=auto --quiet "" "$HOME"/.shrc
    then
        alias grep='grep --color=auto'
    fi
    if quiet ls --color=auto --format=across --directory /
    then
        alias ls='ls --color=auto --format=across'
    else
        alias ls='ls -x'
    fi
fi

# show the most recently changed file
latest()
{
    if test $# -ne 0
    then
        ls -t -1 -d "$@" | head -n 1
    else
        ls -t -1 -d * | head -n 1
    fi
}

# make with an automatic log and pager
m()
{
    command make "$@" 2>&1 1>&- 1>make.log | tee -a make.log
}

# search for a pattern in text files in a directory tree
rgrep()
{
    typeset pattern
    typeset dirs
    typeset args

    args=
    while true
    do
        case $1 in
        -*)
            args="${args:+$args }$1"
            shift
            ;;
        *)
            break
            ;;
        esac
    done
    if test $# -gt 0
    then
        pattern="$1"
        shift
    else
        pattern=
    fi

    if grep -HRq "" .
    then
        grep -HR "$pattern" "${@:-.}"
    else
        find "${@:-.}" -type f -print | xargs -i grep $args "$pattern" {} /dev/null
    fi
}

# list all instances of a command
where()
{
    type -a "$@"
}

### PROGRAM SETTINGS
# set preferred generic utilities
exists lynx && export BROWSER=lynx
exists links && export BROWSER=links
exists elinks && export BROWSER=elinks
exists rsh && export CVS_RSH=rsh
exists ssh && export CVS_RSH=ssh
exists vi && export EDITOR=vi
exists vim && export EDITOR=vim
exists more && export PAGER=more
exists less && export PAGER=less
export VISUAL="$EDITOR"
export WINTERM=xterm

# set file locations
test -r "$HOME"/.inputrc && export INPUTRC="$HOME"/.inputrc

# set preferred program options
export CLICOLOR=true
export FIGNORE=
export GREP_COLOR=1
export LESS=-eFj3MRX
test -n "$TABSIZE" && export LESS="${LESS}x${TABSIZE}"
case "$TERM" in
xterm*)
    # colors for black on white
    export LSCOLORS='exbxcxcxfxcxcx'
    export LS_COLORS='no=00:fi=00:di=00;34:ln=00;31:or=07;31:so=00;32:pi=00;32:ex=00;35:bd=00;32:cd=00;32:'
    ;;
*)
    # colors for white on black
    export LSCOLORS='exgxfxfxcxfxfx'
    export LS_COLORS='no=00:fi=00:di=00;34:ln=00;36:or=07;36:so=00;35:pi=00;35:ex=00;32:bd=00;35:cd=00;35:'
    ;;
esac
if exists dircolors
then
    if test -f "$HOME/.dircolors.$TERM"
    then
        eval $(dircolors "$HOME/.dircolors.$TERM")
    elif test -f "$HOME/.dircolors"
    then
        eval $(dircolors "$HOME/.dircolors")
    fi
fi
export TOP=-I
export WANT_SSH_AGENT=1
export WWW_HOME=http://endbracket.net/michael/links

### INTERACTIVE SETTINGS
if tty >/dev/null 2>&1
then
    # get the terminal characteristics
    terminit

    # set prompt and window title
    connectioninfo='${HOST%%.*} ${USER}'
    command=$0
    commandinfo='${command%% *}'
    shellinfo='${PWD}'
    promptchars='$(if test "$laststatus" -ne 0; then echo "*"; elif test $UID -eq 0; then echo "#"; else echo ">"; fi)'
    promptstring='
$(eval echo "${shellinfo}")
$(eval echo "\"${promptchars}\"") '
    title='$(eval echo "${connectioninfo} ${commandinfo}")'

    # set command line editing key bindings
    # this must be after the EDITOR and VISUAL settings
    set -o emacs 2>/dev/null
fi

### LAST COMMANDS
# source local settings (company environment, network, etc.)
test -r "$HOME"/.shrc.local && . "$HOME"/.shrc.local

# apply the user's settings for prompt, title, etc.
PS1='$(eval settitle "\"${title}\"")''$(eval echo "\"${bold}${promptstring}${normal}\"")'

# vi: set sw=4 ts=33:
