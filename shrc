# $Id$
#
# POSIX shell startup commands
#
# This script contains functions and settings that are common for all
# POSIX-compatible shells including bash, ksh, and zsh.
#
#

# ensure this shell supports local variables using either local
# (from bash and zsh) or typeset (from ksh)
if ! type local >/dev/null 2>/dev/null
then
    if type typeset >/dev/null 2>/dev/null
    then
        alias local='typeset'
    else
        echo "Cannot find local or typeset shell command, some features in .shrc will not work" 1>&2
    fi
fi

### HELPER FUNCTIONS
# add a directory to the path
addpath()
{
    local _adddir
    local _position
    local _pathvar
    local _separator
    _adddir=$1
    _position=$2
    _pathvar=${3:-"PATH"}
    _separator=${4:-":"}
    OIFS="$IFS"
    IFS="$_separator"

    case "$_position" in
    start)
        delpath "$_adddir" "$_pathvar" "$_separator"
        eval $_pathvar="\$_adddir""\${$_pathvar:+\$_separator}""\$$_pathvar"
        ;;
    end)
        delpath "$_adddir" "$_pathvar" "$_separator"
        eval $_pathvar="\$$_pathvar""\${$_pathvar:+\$_separator}""\$_adddir"
        ;;
    *)
        local dirs
        local seen
        eval dirs=\$$_pathvar
        for d in $dirs
        do
            # directory is already in PATH, leave as is
            test "${_adddir:-.}" = "${d:-.}" && seen=true
        done
        test -z "$seen" && eval $_pathvar="\$$_pathvar""\${$_pathvar:+$_separator}""\$_adddir"
        ;;
    esac
    IFS="$OIFS"
}

# remove a directory from the path
delpath()
{
    local _deldir
    local _pathvar
    local _separator
    _deldir=$1
    _pathvar=${2:-"PATH"}
    _separator=${3:-":"}
    NIFS="$IFS"
    IFS="$_separator"

    local _newdirs
    local _olddirs

    eval _olddirs=\$$_pathvar
    _newdirs=
    for d in $_olddirs
    do
        test "${d:-.}" = "${_deldir:-.}" && continue
        _newdirs="$_newdirs""${_newdirs:+$_separator}""$d"
    done
    eval $_pathvar="\$_newdirs"
    IFS="$NIFS"
}

# return true if the command can be found, false otherwise
exists()
{
    local cmd
    cmd="$1"

    if type "$cmd" >/dev/null 2>&1
    then
        return 0
    else
        return 1
    fi
}

# print an error message
error()
{
    echo "$@" 1>&2
}

# run a simple command quietly
quiet()
{
    "$@" >/dev/null 2>&1
    return $?
}

# set the xterm title
settitle()
{
    test -z "${titlestart}" && return 0

    printf "${titlestart}$*${titlefinish}"
}

terminit()
{
    # determine the graphics mode escape sequences
    if exists tput
    then
        if quiet tput longname
        then
            bold="$(tput bold)"
            underline="$(tput smul)"
            normal="$(tput sgr0)"
            black="$(tput setaf 0)"
            red="$(tput setaf 1)"
            green="$(tput setaf 2)"
            yellow="$(tput setaf 3)"
            blue="$(tput setaf 4)"
            magenta="$(tput setaf 5)"
            cyan="$(tput setaf 6)"
            white="$(tput setaf 7)"
        fi
    fi

    # determine the window title escape sequences
    case "$TERM" in
    aixterm|dtterm|putty|rxvt|xterm*)
        titlestart=']0;'
        titlefinish=''
        ;;
    cygwin)
        titlestart='];'
        titlefinish=''
        ;;
    screen*)
        # status line
        #titlestart='_'
        # window title
        titlestart='k'
        titlefinish='\'
        ;;
    *)
        if exists tput
        then
            if quiet tput longname
            then
                titlestart=`tput tsl`
                titlefinish=`tput fsl`
            fi
        else
            titlestart=''
            titlefinish=''
        fi
        ;;
    esac
}

### SHELL ENVIRONMENT
# set shell options and environment
HISTIGNORE="bg:fg: *"
if test -z "$HOST"
then
    HOST=`hostname`
fi
if exists tty
then
    TTY=`tty`
else
    TTY='?'
fi
if test -z "$UID"
then
    UID=`id -u`
fi
if test -z "$USER"
then
    USER=`id -un`
fi

# set directories to search for commands
# add preferred locations at start
# X Window system directories are deprecated on most Linux distributions
# where they are now just symlinks to /usr/bin
# if we add the symlink versions before the standard directories such as
# /usr/bin, some utilities get confused, so only add them to PATH if
# they're not symlinks
for dir in /usr/X11R6/bin /usr/bin/X11
do
    test -d "$dir" && test ! -L "$dir" && addpath "$dir" start
done
for dir in /usr/kerberos/bin /usr/posix/bin /usr/gnu/bin /usr/local/bin "$HOME"/bin
do
    test -d "$dir" && addpath "$dir" start
done
# add standard locations if they're not there
for dir in /usr/bin /bin /usr/sbin /sbin
do
    test -d "$dir" && addpath "$dir"
done
# add the current directory to the end for non-root users
if test $UID -ne 0
then
    for dir in .
    do
        test -d "$dir" && addpath "$dir" end
    done
fi
export PATH

# set directories to search for documentation
for dir in /usr/local/share/info /usr/local/info "$HOME"/info
do
    test -d "$dir" && addpath "$dir" start INFOPATH
done
for dir in /usr/share/info /usr/info
do
    test -d "$dir" && addpath "$dir" end INFOPATH
done
export INFOPATH
for dir in /usr/X11R6/man /usr/kerberos/man /usr/posix/man /usr/gnu/man /usr/local/share/man /usr/local/man "$HOME"/man
do
    test -d "$dir" && addpath "$dir" start MANPATH
done
for dir in /usr/share/man /usr/man
do
    test -d "$dir" && addpath "$dir" end MANPATH
done
export MANPATH

### ALIASES AND FUNCTIONS
# create aliases for commonly invoked commands
if quiet alias
then
    alias apt='aptitude'
    alias bell='echo "\a"'
    alias cx='chmod +x'
    alias e='${EDITOR:-vi}'
    alias edit='${EDITOR:-vi}'
    alias g='grep -EHIin'        # -H and -I are non-POSIX but are widely supported
    alias gdb='gdb -q '
    alias h='history'
    alias hup='kill -HUP'
    alias l='ls'
    alias l.='l -d .*'
    alias la='l -A'
    alias ll='l -l'
    alias lt='l -lt'
    alias j='jobs'
    alias nohup='nohup '         # expand aliases after nohup
    alias pd='pushd'
    alias po='popd'
    alias psme='ps -f -U "${USER:-${LOGNAME}}"'
    alias rcslog='rlog'
    alias rdiff='rcsdiff'
    alias strace='strace '       # expand aliases after strace
    alias sudo='sudo '           # expand aliases after sudo
    alias tailmail='tail "$HOME/.proclog"'
    alias tm='t -f /var/log/mail'
    alias tp='t "$HOME/.proclog"'
    alias today='date "+%Y%m%d"'
    alias v='${VIEWER:-view}'

    # set default flags
    if quiet grep --color=auto --quiet "" "$HOME"/.shrc
    then
        alias grep='grep --color=auto'
    fi
    if quiet ls --format=single-column --classify --color=auto --directory /
    then
        alias ls='ls --format=single-column --classify --color=auto'
    else
        alias ls='ls -1F'
    fi
fi

# edit the most recently changed file
editlatest()
{
    edit $(latest "$@")
}

# show the most recently changed file
latest()
{
    if test $# -ne 0
    then
        /bin/ls -t -1 -d "$@" | head -n 1
    else
        /bin/ls -t -1 -d * | head -n 1
    fi
}

# make with an automatic log and pager
m()
{
    command make "$@" 2>&1 1>&- 1>make.log | tee -a make.log
}

# search for a pattern in text files in a directory tree
rgrep()
{
    local pattern
    local dirs
    local args

    args=
    while true
    do
        case $1 in
        -*)
            args="${args:+$args }$1"
            shift
            ;;
        *)
            break
            ;;
        esac
    done
    if test $# -gt 0
    then
        pattern="$1"
        shift
    else
        pattern=
    fi

    if grep -HRq "" .
    then
        grep -HR "$pattern" "${@:-.}"
    else
        find "${@:-.}" -type f -print | xargs -i grep $args "$pattern" {} /dev/null
    fi
}

# print the last screenful of text from a file
t()
{
    local lines
    local promptlines
    promptlines=5                # leave five lines for the prompt
    if test -n $LINES
    then
        lines=$(($LINES - $promptlines))
    else
        lines=$(tput lines)
        if test -z $lines
        then
            lines=24
        fi
    fi

    tail -n $lines "$@"
}

# list all instances of a command
where()
{
    type -a "$@"
}

### PROGRAM SETTINGS
# set preferred generic utilities
exists lynx && export BROWSER=lynx
exists links && export BROWSER=links
exists elinks && export BROWSER=elinks
exists rsh && export CVS_RSH=rsh
exists ssh && export CVS_RSH=ssh
exists ed && export EDITOR=ed
exists vi && export EDITOR=vi
exists more && export VIEWER=more
exists less && export VIEWER=less
exists view && export VIEWER=view
exists more && export PAGER=more
exists less && export PAGER=less
export VISUAL="$EDITOR"
export WINTERM=xterm

if test -f "$HOME"/.keychain/"$HOST"-sh
then
    . "$HOME"/.keychain/"$HOST"-sh
fi

# set file locations
test -r "$HOME"/.inputrc && export INPUTRC="$HOME"/.inputrc

# set preferred program options
export CLICOLOR=true
export FIGNORE=
export GREP_COLOR=4
export LESS=-eFj3MRX
test -n "$TABSIZE" && export LESS="${LESS}x${TABSIZE}"
case "$TERM" in
xterm*)
    # colors for black on white
    export LSCOLORS='exbxcxcxfxcxcx'
    export LS_COLORS='no=00:fi=00:di=00;34:ln=00;31:or=07;31:so=00;32:pi=00;32:ex=00;35:bd=00;32:cd=00;32:'
    ;;
*)
    # colors for white on black
    export LSCOLORS='exgxfxfxcxfxfx'
    export LS_COLORS='no=00:fi=00:di=00;33:ln=00;36:or=07;36:so=00;35:pi=00;35:ex=00;32:bd=00;35:cd=00;35:'
    ;;
esac
if exists dircolors
then
    if test -f "$HOME/.dircolors.$TERM"
    then
        eval $(dircolors "$HOME/.dircolors.$TERM")
    elif test -f "$HOME/.dircolors"
    then
        eval $(dircolors "$HOME/.dircolors")
    fi
fi
export TOP=-I
export WANT_SSH_AGENT=1
export WWW_HOME=http://google.com

### INTERACTIVE SETTINGS
if tty >/dev/null 2>&1
then
    # get the terminal characteristics
    terminit

    # set prompt and window title
    connectioninfo='${HOST%%.*} ${USER}'
    command=${0#-}
    commandinfo='$(echo "$command" | sed -e "s/^-//" -e "s#^[^ ]*/##" -e "s/ .*$//")'
    shellinfo='${PWD}'
    promptchars='$(if test ${laststatus:-0} -ne 0; then echo "?"; elif test $UID -eq 0; then echo "#"; else echo ">"; fi)'
    if test $UID -eq 0
    then
        promptcolor=red
    else
        promptcolor=normal
    fi
    promptstring='
$(eval echo "${shellinfo}")$(eval echo "\"${promptchars}\"") '
    case "${TERM}" in
    #screen*)
    #    title='$(eval echo "${commandinfo}")'
    #    ;;
    *)
        title='$(eval echo "${commandinfo} ${connectioninfo}")'
        ;;
    esac

    # set command line editing key bindings
    # this must be after the EDITOR and VISUAL settings
    set -o emacs 2>/dev/null
fi

### LAST COMMANDS
# source local settings (company environment, network, etc.)
test -r "$HOME"/.shrc.local && . "$HOME"/.shrc.local

# apply the user's settings for prompt, title, etc.
# we differentiate here between ksh and sh,
# prompts for bash and zsh are handled in .bashrc, .zshrc, etc.
case $0 in
*ksh*)
    PS1='$(eval settitle "\"${title}\"")''$(eval echo "\"\$${promptcolor:-normal}${promptstring}${normal}\"")'
    ;;
*)
    PS1="$(eval echo $promptchars) "
esac

# finish with a 0 exit status
true

# vi: set sw=4 ts=33:
