# POSIX shell environment
#
# This script contains functions, aliases and settings that are common for all
# POSIX-compatible shells including bash, ksh, and zsh.
#
# $Id: shrc 1618 2008-03-06 23:24:24Z mikel $

# ensure this shell supports local variables using either local
# (from bash and zsh) or typeset (from ksh)
if ! type local >/dev/null 2>&1
then
	if type typeset >/dev/null 2>&1
	then
		echo creating local alias
		alias local='typeset'
		alias
	else
		echo "Cannot find local or typeset shell command, some features in .shrc will not work" 1>&2
	fi
fi

### HELPER FUNCTIONS
#
# add a directory to the path
addpath()
{
	local _adddir
	local _position
	local _pathvar
	local _separator
	_adddir=$1
	_position=$2
	_pathvar=${3:-"PATH"}
	_separator=${4:-":"}
	OIFS="$IFS"
	IFS="$_separator"

	case "$_position" in
	start)
		delpath "$_adddir" "$_pathvar" "$_separator"
		eval $_pathvar="\$_adddir""\${$_pathvar:+\$_separator}""\$$_pathvar"
		;;
	end)
		delpath "$_adddir" "$_pathvar" "$_separator"
		eval $_pathvar="\$$_pathvar""\${$_pathvar:+\$_separator}""\$_adddir"
		;;
	*)
		local dirs
		local seen
		eval dirs=\$$_pathvar
		for d in $dirs
		do
			# directory is already in PATH, leave as is
			test "${_adddir:-.}" = "${d:-.}" && seen=true
		done
		test -z "$seen" && eval $_pathvar="\$$_pathvar""\${$_pathvar:+$_separator}""\$_adddir"
		;;
	esac
	IFS="$OIFS"
}

# list processes in D state
blocked()
{
	ps -e -o stat= -o pid= -o comm=   | awk '$1 ~ /D/ { print }'
}

# remove a directory from the path
delpath()
{
	local _deldir
	local _pathvar
	local _separator
	_deldir=$1
	_pathvar=${2:-"PATH"}
	_separator=${3:-":"}
	NIFS="$IFS"
	IFS="$_separator"

	local _newdirs
	local _olddirs

	eval _olddirs=\$$_pathvar
	_newdirs=
	for d in $_olddirs
	do
		test "${d:-.}" = "${_deldir:-.}" && continue
		_newdirs="$_newdirs""${_newdirs:+$_separator}""$d"
	done
	eval $_pathvar="\$_newdirs"
	IFS="$NIFS"
}

# return true if the command can be found, false otherwise
exists()
{
	local cmd
	cmd="$1"

	if type "$cmd" >/dev/null 2>&1
	then
		return 0
	else
		return 1
	fi
}

# print an error message
error()
{
	echo "$@" 1>&2
}

# print lines from a file 
# starting with the line matching $1 
# finishing with the line matching $2 
from_to() 
{ 
    local from 
    local to 
    from=$1 
    to=$2 
    shift 2 
 
    sed -ne "/$from/ b INSIDE 
d 
: INSIDE { 
p 
/$to/ q 
n 
b INSIDE 
} 
: END" "$@" 
}

# return the last component of the path
# (like basename, but guaranteed to be available)
last_part_of_path()
{
	local full_path="$1"
	full_path="${full_path%/}"

	if test -n "$full_path"
	then
		echo "${full_path##*/}"
	else
		echo "/"
	fi
}

# process list with status
pss()
{
	ps -e -o pid,stat,stime,args
}

# run a simple command quietly
quiet()
{
	"$@" >/dev/null 2>&1
	return $?
}

# set the xterm title
settitle()
{
	test -z "${titlestart}" && return 0

	printf "${titlestart}$*${titlefinish}"
}

terminit()
{
	# determine the graphics mode escape sequences
	if exists tput
	then
		if quiet tput longname
		then
			bold="$(tput bold)"
			underline="$(tput smul)"
			normal="$(tput sgr0)"
			black="$(tput setaf 0)"
			red="$(tput setaf 1)"
			green="$(tput setaf 2)"
			yellow="$(tput setaf 3)"
			blue="$(tput setaf 4)"
			magenta="$(tput setaf 5)"
			cyan="$(tput setaf 6)"
			white="$(tput setaf 7)"

			home="$(tput khome)"
			end="$(tput kend)"
		fi
	fi

	# determine the window title escape sequences
	case "$TERM" in
	aixterm|dtterm|putty|rxvt|xterm*)
		titlestart=']0;'
		titlefinish=''
		#titlestart='\033]0;'
		#titlefinish='\007'
		;;
	cygwin)
		titlestart='];'
		titlefinish=''
		;;
	konsole)
		titlestart=']30;'
		titlefinish=''
		;;
	screen*)
		# status line
		#titlestart='_'
		#titlefinish='\'
		# window title
		titlestart='k'
		titlefinish='\'
		;;
	*)
		if exists tput
		then
			if quiet tput longname
			then
				titlestart="$(tput tsl)"
				titlefinish="$(tput fsl)"
			fi
		else
			titlestart=''
			titlefinish=''
		fi
		;;
	esac
}

### SHELL ENVIRONMENT
# set shell options and environment
HISTIGNORE="bg:fg: *"
HISTSIZE=128
if test -z "$HOST"
then
	HOST=$(hostname)
fi
if exists tty
then
	TTY=$(tty)
else
	TTY='?'
fi
if test -z "$UID"
then
	UID=$(id -u)
fi
if test -z "$USER"
then
	USER=$(id -un)
fi

# set directories to search for commands
# add preferred locations at start
# X Window system directories are deprecated on most Linux distributions
# where they are now just symlinks to /usr/bin
# if we add the symlink versions before the standard directories such as
# /usr/bin, some utilities get confused, so only add them to PATH if
# they're not symlinks
for dir in /usr/X11R6/bin /usr/bin/X11
do
	test -d "$dir" && test ! -L "$dir" && addpath "$dir" start
done
for dir in /usr/kerberos/bin /usr/posix/bin /usr/gnu/bin /usr/local/bin "$HOME"/bin
do
	test -d "$dir" && addpath "$dir" start
done
# add standard locations if they're not there
for dir in /usr/bin /bin /usr/sbin /sbin
do
	test -d "$dir" && addpath "$dir"
done
# add the current directory to the end for non-root users
if test $UID -ne 0
then
	for dir in .
	do
		test -d "$dir" && addpath "$dir" end
	done
fi
export PATH

# set directories to search for documentation
for dir in /usr/local/share/info /usr/local/info "$HOME"/info
do
	test -d "$dir" && addpath "$dir" start INFOPATH
done
for dir in /usr/share/info /usr/info
do
	test -d "$dir" && addpath "$dir" end INFOPATH
done
export INFOPATH
for dir in /usr/X11R6/man /usr/kerberos/man /usr/posix/man /usr/gnu/man /usr/local/share/man /usr/local/man "$HOME"/man
do
	test -d "$dir" && addpath "$dir" start MANPATH
done
for dir in /usr/share/man /usr/man
do
	test -d "$dir" && addpath "$dir" end MANPATH
done
export MANPATH

### ALIASES AND FUNCTIONS
# create aliases for commonly invoked commands
if quiet alias
then
	# aliase apt to aptitude or apt-get (in that order)
	type apt-get >/dev/null 2>/dev/null && alias apt='apt-get'
	type aptitude >/dev/null 2>/dev/null && alias apt='aptitude'
	alias bell='echo -n "\a"'
	alias c='cd'
	alias cx='chmod +x'
	alias d='dirs'	# only supported by bash and zsh
	alias e='${EDITOR:-vi}'
	alias edit='${EDITOR:-vi}'
	alias g='grep -EHIin'		 # -H and -I are non-POSIX but are widely supported
	alias gdb='gdb -q '
	#alias h=head
	alias hup='kill -HUP'
	alias l='ls'
	alias l.='l -d .*'
	alias la='l -A'
	alias ll='l -l'
	alias lt='l -lt'
	alias j='jobs'
	#alias m=make
	alias nohup='nohup '		 # expand aliases after nohup
	alias pd='pushd'
	alias po='popd'
	alias psme='ps -f -U "${USER:-${LOGNAME}}"'
	alias rb='reportblocked'
	alias rcslog='rlog'
	alias rdiff='rcsdiff'
	alias rg='reportgraylist'
	if command -v assh >/dev/null 2>/dev/null
	then
		alias s='exec assh'
		alias ssh='assh'
	else
		alias s='exec ssh'
	fi
	if command -v ascp >/dev/null 2>/dev/null
	then
		alias scp='ascp'
	fi
	alias strace='strace '		 # expand aliases after strace
	alias sudo='sudo '			 # expand aliases after sudo
	#alias t=tail
	alias tf='tail -n 0 -F'
	alias tm='t -f /var/log/mail'
	alias tp='t -f "$HOME/.proclog"'
	alias today='date "+%Y%m%d"'
	alias v='${VIEWER:-view}'
	alias x='exit'

	# set default flags
	if quiet grep --color=auto --quiet "" "$HOME"/.shrc
	then
		alias grep='grep --color=auto'
	fi
	if quiet ls --color=auto --directory --format=across /
	then
		alias ls='ls --color=auto --format=across'
	else
		alias ls='ls -x'
	fi
fi

# do some floating point arithmetic
calc()
{
	echo "scale=3; $*" | bc
}

# edit the most recently changed file
editlatest()
{
	edit $(latest "$@")
}

# print the first screenful of text from a file
h()
{
	local lines
	local promptlines
	promptlines=5				 # leave five lines for the prompt
	if test -n $LINES
	then
		lines=$(($LINES - $promptlines))
	else
		lines=$(tput lines)
		if test -z $lines
		then
			lines=24
		fi
	fi

	head -n $lines "$@"
}

# show the most recently changed file
latest()
{
	if test $# -ne 0
	then
		/bin/ls -t -1 -d "$@" | head -n 1
	else
		/bin/ls -t -1 -d * | head -n 1
	fi
}

# make with an automatic log and pager
m()
{
	command make "$@" 2>&1 1>&- 1>make.log | tee -a make.log
}

# flash the screen ("visible bell")
flash()
{
	if exists tput
	then
		tput flash
	fi
}

# keep trying a command until it works
# (e.g. ping -c 1 host)
notify()
{
	while true
	do
		"$@"
		if test $? -eq 0
		then
			bell
			break
		else
			sleep 10
		fi
	done
}

# show the 10 most recently changed files
recent()
{
	if test $# -ne 0
	then
		/bin/ls -t -1 "$@" | head -n 10
	else
		/bin/ls -t -1 . | head -n 10
	fi
}

# search for a pattern in text files in a directory tree
rgrep()
{
	local pattern
	local dirs
	local args

	args=
	while true
	do
		case $1 in
		-*)
			args="${args:+$args }$1"
			shift
			;;
		*)
			break
			;;
		esac
	done
	if test $# -ge 1
	then
		pattern="$1"
		shift
	fi

	if grep -HRq "" .
	then
		grep -HR "$pattern" "$@"
	else
		find "${@:-.}" -type f -print | xargs -i grep $args "$pattern" {} /dev/null
	fi
}

# print the escape sequence for the named color (e.g. setcolor "blue")
setcolor()
{
	local color
	color="$1"
	if test -n "$color"
	then
		eval echo -n "\"\$$color\""
	fi
}

# get a short version of the current command (strips path and arguments)
short_command()
{
	local command
	command=$1

	echo "$command" | sed -e "s/^-//" -e "s#^[^ ]*/##" -e "s/ .*$//"
}

# get a short version of the hostname for use in the prompt or window title
short_hostname()
{
	local domains
	# domain that we want to keep the subdomain for
	domain="acx"

	if test -n "$HOST"
	then
		if echo "$HOST" | grep -q "\.$domain"
		then
			echo "$HOST" | sed -e "s/\.$domain//"
		else
			echo "$HOST" | sed -e "s/\..*//"
		fi
		return 0
	else
		echo "unknown"
		return 1
	fi
}

# look up the password for a user@host combination
pass()
{
	typeset user
	typeset host

	if test -z "$PASSFILE"
	then
		error "PASSFILE not set"
		return 1
	fi

	if expr "$1" : "..*@..*" >/dev/null
	then
		user=${1%%@*}
		host=${1##*@}
	else
		host="$1"
		user="$2"
	fi

	if test -n "$user"
	then
		awk "\$1 == \"$host\" && \$2 == \"$user\" { printf \"%s\n\", \$3 }" "$PASSFILE"
	else
		awk "\$1 == \"$host\" { printf \"%s\t%s\n\", \$2, \$3 }" "$PASSFILE"
	fi
}

prompt_character()
{
	#if test ${laststatus:-0} -ne 0; then
	#	echo "!"
	if test $UID -eq 0; then
		echo "#"
	else
		#echo "$"
		echo ">"
	fi
}

# print the last screenful of text from a file
t()
{
	local lines
	local promptlines
	promptlines=5				 # leave five lines for the prompt
	if test -n $LINES
	then
		lines=$(($LINES - $promptlines))
	else
		lines=$(tput lines)
		if test -z $lines
		then
			lines=24
		fi
	fi

	tail -n $lines "$@"
}

# print the current directory with $HOME changed to ~
tilde_directory()
{
	if test $UID -eq 0; then
		pwd
	else
		pwd | sed -e 's#'"$HOME"'#~#'
	fi
}

# list all instances of a command
where()
{
	type -a "$@"
}

# show which YUM repository/repositories have the named package
# (a bit like apt-cache policy)
yumpolicy()
{
	repoquery -a --qf '%-20{repoid} %{name}-%{version}' "$@"
}

### PROGRAM SETTINGS
# set preferred generic utilities
if test -n "$DISPLAY"
then
	exists netscape && export BROWSER=netscape
	exists mozilla && export BROWSER=mozilla
	exists opera && export BROWSER=opera
	exists firefox && export BROWSER=firefox
else
	exists lynx && export BROWSER=lynx
	exists links && export BROWSER=links
	exists elinks && export BROWSER=elinks
fi
exists rsh && export CVS_RSH=rsh
exists ssh && export CVS_RSH=ssh
exists ed && export EDITOR=ed
exists vi && export EDITOR=vi
exists more && export VIEWER=more
exists less && export VIEWER=less
exists view && export VIEWER=view
exists more && export PAGER=more
exists less && export PAGER=less
export VISUAL="$EDITOR"
export WINTERM=xterm

if test -f "$HOME"/.keychain/"$HOST"-sh
then
	. "$HOME"/.keychain/"$HOST"-sh
fi

# set file locations
test -r "$HOME"/.inputrc && export INPUTRC="$HOME"/.inputrc

# set preferred program options
export CLICOLOR=true
export FIGNORE=
export GREP_COLOR=4
export LESS=-eFj3MRX
test -n "$TABSIZE" && export LESS="${LESS}x${TABSIZE}"

export TOP=-I
export WANT_SSH_AGENT=1
export WWW_HOME=http://google.com

true
